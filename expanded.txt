#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
extern crate blas_src;
use crate::driver::RISMDriver;
use pyo3::prelude::*;
pub mod closure {
    use crate::data::DataRs;
    use ndarray::{par_azip, Array, Array3};
    use pyo3::{prelude::*, types::PyString};
    use std::fmt;
    pub enum ClosureKind {
        HyperNettedChain,
        KovalenkoHirata,
        PercusYevick,
        PartialSeriesExpansion(i8),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for ClosureKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                ClosureKind::HyperNettedChain => {
                    ::core::fmt::Formatter::write_str(f, "HyperNettedChain")
                }
                ClosureKind::KovalenkoHirata => {
                    ::core::fmt::Formatter::write_str(f, "KovalenkoHirata")
                }
                ClosureKind::PercusYevick => {
                    ::core::fmt::Formatter::write_str(f, "PercusYevick")
                }
                ClosureKind::PartialSeriesExpansion(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "PartialSeriesExpansion",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for ClosureKind {
        #[inline]
        fn clone(&self) -> ClosureKind {
            match self {
                ClosureKind::HyperNettedChain => ClosureKind::HyperNettedChain,
                ClosureKind::KovalenkoHirata => ClosureKind::KovalenkoHirata,
                ClosureKind::PercusYevick => ClosureKind::PercusYevick,
                ClosureKind::PartialSeriesExpansion(__self_0) => {
                    ClosureKind::PartialSeriesExpansion(
                        ::core::clone::Clone::clone(__self_0),
                    )
                }
            }
        }
    }
    impl<'source> FromPyObject<'source> for ClosureKind {
        fn extract(obj: &'source PyAny) -> PyResult<Self> {
            let str = obj
                .downcast::<PyString>()?
                .to_str()
                .map(ToOwned::to_owned)
                .expect("could not convert string");
            match str.as_str() {
                "HNC" => Ok(ClosureKind::HyperNettedChain),
                "KH" => Ok(ClosureKind::KovalenkoHirata),
                "PSE-1" => Ok(ClosureKind::PartialSeriesExpansion(1)),
                "PSE-2" => Ok(ClosureKind::PartialSeriesExpansion(2)),
                "PSE-3" => Ok(ClosureKind::PartialSeriesExpansion(3)),
                "PSE-4" => Ok(ClosureKind::PartialSeriesExpansion(4)),
                "PSE-5" => Ok(ClosureKind::PartialSeriesExpansion(5)),
                "PY" => Ok(ClosureKind::PercusYevick),
                _ => {
                    ::core::panicking::panic_fmt(format_args!("not a valid closure"));
                }
            }
        }
    }
    impl fmt::Display for ClosureKind {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                ClosureKind::HyperNettedChain => {
                    f.write_fmt(format_args!("Hyper-Netted Chain"))
                }
                ClosureKind::KovalenkoHirata => {
                    f.write_fmt(format_args!("Kovalenko-Hirata"))
                }
                ClosureKind::PercusYevick => f.write_fmt(format_args!("Percus-Yevick")),
                ClosureKind::PartialSeriesExpansion(x) => {
                    f.write_fmt(format_args!("Partial Series Expansion ({0} terms)", x))
                }
            }
        }
    }
    impl ClosureKind {
        pub fn set(&self) -> fn(&DataRs) -> Array3<f64> {
            match self {
                ClosureKind::HyperNettedChain => hyper_netted_chain,
                ClosureKind::KovalenkoHirata => kovalenko_hirata,
                ClosureKind::PercusYevick => percus_yevick,
                ClosureKind::PartialSeriesExpansion(x) => {
                    let n = x.to_owned();
                    let func = (/*ERROR*/);
                    func
                }
            }
        }
    }
    pub fn hyper_netted_chain(problem: &DataRs) -> Array3<f64> {
        (-problem.system.beta * &problem.interactions.u_sr + &problem.correlations.tr)
            .mapv(|a| a.exp()) - 1.0 - &problem.correlations.tr
    }
    pub fn kovalenko_hirata(problem: &DataRs) -> Array3<f64> {
        let mut out = Array::zeros(problem.correlations.tr.raw_dim());
        ::ndarray::Zip::from(&mut out)
            .and(
                &(-problem.system.beta * &problem.interactions.u_sr
                    + &problem.correlations.tr),
            )
            .and(&problem.correlations.tr)
            .par_for_each(|a, &b, &c| {
                if b <= 0.0 { *a = b.exp() - 1.0 - c } else { *a = b - c }
            });
        out
    }
    pub fn percus_yevick(problem: &DataRs) -> Array3<f64> {
        (-problem.system.beta * &problem.interactions.u_sr).mapv(|a| a.exp())
            * (1.0 + &problem.correlations.tr) - 1.0 - &problem.correlations.tr
    }
    pub fn factorial(num: u128) -> u128 {
        (1..=num).product()
    }
}
pub mod data {
    use ndarray::{Array, Array1, Array2, Array3};
    use numpy::{PyArray1, PyArray2, PyArray3};
    use pyo3::prelude::*;
    use std::f64::consts::PI;
    pub struct Site {
        pub atom_type: String,
        pub params: Vec<f64>,
        pub coords: Vec<f64>,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for Site {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(Site {
                    atom_type: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "atom_type",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "Site",
                        "atom_type",
                    )?,
                    params: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "params",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "Site",
                        "params",
                    )?,
                    coords: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "coords",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "Site",
                        "coords",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Site {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "Site",
                "atom_type",
                &self.atom_type,
                "params",
                &self.params,
                "coords",
                &&self.coords,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Site {
        #[inline]
        fn clone(&self) -> Site {
            Site {
                atom_type: ::core::clone::Clone::clone(&self.atom_type),
                params: ::core::clone::Clone::clone(&self.params),
                coords: ::core::clone::Clone::clone(&self.coords),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Site {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Site {
        #[inline]
        fn eq(&self, other: &Site) -> bool {
            self.atom_type == other.atom_type && self.params == other.params
                && self.coords == other.coords
        }
    }
    pub struct Species {
        pub species_name: String,
        pub dens: f64,
        pub ns: usize,
        pub atom_sites: Vec<Site>,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for Species {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(Species {
                    species_name: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "species_name",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "Species",
                        "species_name",
                    )?,
                    dens: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "dens",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "Species",
                        "dens",
                    )?,
                    ns: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "ns",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "Species",
                        "ns",
                    )?,
                    atom_sites: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "atom_sites",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "Species",
                        "atom_sites",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Species {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Species",
                "species_name",
                &self.species_name,
                "dens",
                &self.dens,
                "ns",
                &self.ns,
                "atom_sites",
                &&self.atom_sites,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Species {
        #[inline]
        fn clone(&self) -> Species {
            Species {
                species_name: ::core::clone::Clone::clone(&self.species_name),
                dens: ::core::clone::Clone::clone(&self.dens),
                ns: ::core::clone::Clone::clone(&self.ns),
                atom_sites: ::core::clone::Clone::clone(&self.atom_sites),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Species {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Species {
        #[inline]
        fn eq(&self, other: &Species) -> bool {
            self.species_name == other.species_name && self.dens == other.dens
                && self.ns == other.ns && self.atom_sites == other.atom_sites
        }
    }
    pub struct DataConfig {
        pub temp: f64,
        pub kt: f64,
        pub ku: f64,
        pub amph: f64,
        pub drism_damping: Option<f64>,
        pub dielec: Option<f64>,
        pub nsv: usize,
        pub nsu: Option<usize>,
        pub nspv: usize,
        pub nspu: Option<usize>,
        pub npts: usize,
        pub radius: f64,
        pub nlambda: usize,
        pub solvent_atoms: Vec<Site>,
        pub solute_atoms: Option<Vec<Site>>,
        pub solvent_species: Vec<Species>,
        pub solute_species: Option<Vec<Species>>,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for DataConfig {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(DataConfig {
                    temp: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "temp",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "temp",
                    )?,
                    kt: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "kt",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "kt",
                    )?,
                    ku: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "ku",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "ku",
                    )?,
                    amph: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "amph",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "amph",
                    )?,
                    drism_damping: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "drism_damping",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "drism_damping",
                    )?,
                    dielec: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "dielec",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "dielec",
                    )?,
                    nsv: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "nsv",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "nsv",
                    )?,
                    nsu: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "nsu",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "nsu",
                    )?,
                    nspv: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "nspv",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "nspv",
                    )?,
                    nspu: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "nspu",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "nspu",
                    )?,
                    npts: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "npts",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "npts",
                    )?,
                    radius: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "radius",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "radius",
                    )?,
                    nlambda: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "nlambda",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "nlambda",
                    )?,
                    solvent_atoms: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "solvent_atoms",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "solvent_atoms",
                    )?,
                    solute_atoms: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "solute_atoms",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "solute_atoms",
                    )?,
                    solvent_species: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "solvent_species",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "solvent_species",
                    )?,
                    solute_species: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "solute_species",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "DataConfig",
                        "solute_species",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for DataConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "temp",
                "kt",
                "ku",
                "amph",
                "drism_damping",
                "dielec",
                "nsv",
                "nsu",
                "nspv",
                "nspu",
                "npts",
                "radius",
                "nlambda",
                "solvent_atoms",
                "solute_atoms",
                "solvent_species",
                "solute_species",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.temp,
                &self.kt,
                &self.ku,
                &self.amph,
                &self.drism_damping,
                &self.dielec,
                &self.nsv,
                &self.nsu,
                &self.nspv,
                &self.nspu,
                &self.npts,
                &self.radius,
                &self.nlambda,
                &self.solvent_atoms,
                &self.solute_atoms,
                &self.solvent_species,
                &&self.solute_species,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "DataConfig",
                names,
                values,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DataConfig {
        #[inline]
        fn clone(&self) -> DataConfig {
            DataConfig {
                temp: ::core::clone::Clone::clone(&self.temp),
                kt: ::core::clone::Clone::clone(&self.kt),
                ku: ::core::clone::Clone::clone(&self.ku),
                amph: ::core::clone::Clone::clone(&self.amph),
                drism_damping: ::core::clone::Clone::clone(&self.drism_damping),
                dielec: ::core::clone::Clone::clone(&self.dielec),
                nsv: ::core::clone::Clone::clone(&self.nsv),
                nsu: ::core::clone::Clone::clone(&self.nsu),
                nspv: ::core::clone::Clone::clone(&self.nspv),
                nspu: ::core::clone::Clone::clone(&self.nspu),
                npts: ::core::clone::Clone::clone(&self.npts),
                radius: ::core::clone::Clone::clone(&self.radius),
                nlambda: ::core::clone::Clone::clone(&self.nlambda),
                solvent_atoms: ::core::clone::Clone::clone(&self.solvent_atoms),
                solute_atoms: ::core::clone::Clone::clone(&self.solute_atoms),
                solvent_species: ::core::clone::Clone::clone(&self.solvent_species),
                solute_species: ::core::clone::Clone::clone(&self.solute_species),
            }
        }
    }
    pub struct Grid {
        pub npts: usize,
        pub radius: f64,
        pub dr: f64,
        pub dk: f64,
        pub rgrid: Array1<f64>,
        pub kgrid: Array1<f64>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Grid {
        #[inline]
        fn clone(&self) -> Grid {
            Grid {
                npts: ::core::clone::Clone::clone(&self.npts),
                radius: ::core::clone::Clone::clone(&self.radius),
                dr: ::core::clone::Clone::clone(&self.dr),
                dk: ::core::clone::Clone::clone(&self.dk),
                rgrid: ::core::clone::Clone::clone(&self.rgrid),
                kgrid: ::core::clone::Clone::clone(&self.kgrid),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Grid {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &["npts", "radius", "dr", "dk", "rgrid", "kgrid"];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.npts,
                &self.radius,
                &self.dr,
                &self.dk,
                &self.rgrid,
                &&self.kgrid,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "Grid", names, values)
        }
    }
    impl Grid {
        pub fn new(npts: usize, radius: f64) -> Self {
            let dr = radius / npts as f64;
            let dk = 2.0 * PI / (2.0 * npts as f64 * dr);
            Grid {
                npts,
                radius,
                dr,
                dk,
                rgrid: Array1::range(0.5, npts as f64, 1.0) * dr,
                kgrid: Array1::range(0.5, npts as f64, 1.0) * dk,
            }
        }
    }
    pub struct SystemState {
        pub temp: f64,
        pub kt: f64,
        pub amph: f64,
        pub nlam: usize,
        pub beta: f64,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SystemState {
        #[inline]
        fn clone(&self) -> SystemState {
            SystemState {
                temp: ::core::clone::Clone::clone(&self.temp),
                kt: ::core::clone::Clone::clone(&self.kt),
                amph: ::core::clone::Clone::clone(&self.amph),
                nlam: ::core::clone::Clone::clone(&self.nlam),
                beta: ::core::clone::Clone::clone(&self.beta),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SystemState {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SystemState",
                "temp",
                &self.temp,
                "kt",
                &self.kt,
                "amph",
                &self.amph,
                "nlam",
                &self.nlam,
                "beta",
                &&self.beta,
            )
        }
    }
    impl SystemState {
        pub fn new(temp: f64, kt: f64, amph: f64, nlam: usize) -> Self {
            SystemState {
                temp,
                kt,
                amph,
                nlam,
                beta: 1.0 / kt / temp,
            }
        }
        pub fn recompute_beta(&mut self) {
            self.beta = 1.0 / self.kt / self.temp;
        }
    }
    pub struct SingleData {
        pub sites: Vec<Site>,
        pub species: Vec<Species>,
        pub density: Array2<f64>,
        pub wk: Array3<f64>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SingleData {
        #[inline]
        fn clone(&self) -> SingleData {
            SingleData {
                sites: ::core::clone::Clone::clone(&self.sites),
                species: ::core::clone::Clone::clone(&self.species),
                density: ::core::clone::Clone::clone(&self.density),
                wk: ::core::clone::Clone::clone(&self.wk),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SingleData {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "SingleData",
                "sites",
                &self.sites,
                "species",
                &self.species,
                "density",
                &self.density,
                "wk",
                &&self.wk,
            )
        }
    }
    impl SingleData {
        pub fn new(
            sites: Vec<Site>,
            species: Vec<Species>,
            shape: (usize, usize, usize),
        ) -> Self {
            let density = {
                let mut dens_vec: Vec<f64> = Vec::new();
                for i in species.clone().into_iter() {
                    for _j in i.atom_sites {
                        dens_vec.push(i.dens);
                    }
                }
                let density = Array2::from_diag(&Array::from_vec(dens_vec));
                density
            };
            SingleData {
                sites,
                species,
                density,
                wk: Array::zeros(shape),
            }
        }
    }
    pub struct Interactions {
        pub ur: Array3<f64>,
        pub u_sr: Array3<f64>,
        pub ur_lr: Array3<f64>,
        pub uk_lr: Array3<f64>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Interactions {
        #[inline]
        fn clone(&self) -> Interactions {
            Interactions {
                ur: ::core::clone::Clone::clone(&self.ur),
                u_sr: ::core::clone::Clone::clone(&self.u_sr),
                ur_lr: ::core::clone::Clone::clone(&self.ur_lr),
                uk_lr: ::core::clone::Clone::clone(&self.uk_lr),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Interactions {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Interactions",
                "ur",
                &self.ur,
                "u_sr",
                &self.u_sr,
                "ur_lr",
                &self.ur_lr,
                "uk_lr",
                &&self.uk_lr,
            )
        }
    }
    impl Interactions {
        pub fn new(npts: usize, num_sites_a: usize, num_sites_b: usize) -> Self {
            let shape = (npts, num_sites_a, num_sites_b);
            Interactions {
                ur: Array::zeros(shape),
                u_sr: Array::zeros(shape),
                ur_lr: Array::zeros(shape),
                uk_lr: Array::zeros(shape),
            }
        }
    }
    pub struct Correlations {
        pub cr: Array3<f64>,
        pub tr: Array3<f64>,
        pub hr: Array3<f64>,
        pub hk: Array3<f64>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Correlations {
        #[inline]
        fn clone(&self) -> Correlations {
            Correlations {
                cr: ::core::clone::Clone::clone(&self.cr),
                tr: ::core::clone::Clone::clone(&self.tr),
                hr: ::core::clone::Clone::clone(&self.hr),
                hk: ::core::clone::Clone::clone(&self.hk),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Correlations {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "Correlations",
                "cr",
                &self.cr,
                "tr",
                &self.tr,
                "hr",
                &self.hr,
                "hk",
                &&self.hk,
            )
        }
    }
    pub struct DielectricData {
        pub drism_damping: f64,
        pub diel: f64,
        pub chi: Array3<f64>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DielectricData {
        #[inline]
        fn clone(&self) -> DielectricData {
            DielectricData {
                drism_damping: ::core::clone::Clone::clone(&self.drism_damping),
                diel: ::core::clone::Clone::clone(&self.diel),
                chi: ::core::clone::Clone::clone(&self.chi),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DielectricData {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "DielectricData",
                "drism_damping",
                &self.drism_damping,
                "diel",
                &self.diel,
                "chi",
                &&self.chi,
            )
        }
    }
    impl DielectricData {
        pub fn new(drism_damping: f64, diel: f64, chi: Array3<f64>) -> Self {
            DielectricData {
                drism_damping,
                diel,
                chi,
            }
        }
    }
    impl Correlations {
        pub fn new(npts: usize, num_sites_a: usize, num_sites_b: usize) -> Self {
            let shape = (npts, num_sites_a, num_sites_b);
            Correlations {
                cr: Array::zeros(shape),
                tr: Array::zeros(shape),
                hr: Array::zeros(shape),
                hk: Array::zeros(shape),
            }
        }
    }
    pub struct DataRs {
        pub system: SystemState,
        pub data_a: SingleData,
        pub data_b: SingleData,
        pub grid: Grid,
        pub interactions: Interactions,
        pub correlations: Correlations,
        pub dielectrics: Option<DielectricData>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DataRs {
        #[inline]
        fn clone(&self) -> DataRs {
            DataRs {
                system: ::core::clone::Clone::clone(&self.system),
                data_a: ::core::clone::Clone::clone(&self.data_a),
                data_b: ::core::clone::Clone::clone(&self.data_b),
                grid: ::core::clone::Clone::clone(&self.grid),
                interactions: ::core::clone::Clone::clone(&self.interactions),
                correlations: ::core::clone::Clone::clone(&self.correlations),
                dielectrics: ::core::clone::Clone::clone(&self.dielectrics),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DataRs {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "system",
                "data_a",
                "data_b",
                "grid",
                "interactions",
                "correlations",
                "dielectrics",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.system,
                &self.data_a,
                &self.data_b,
                &self.grid,
                &self.interactions,
                &self.correlations,
                &&self.dielectrics,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "DataRs",
                names,
                values,
            )
        }
    }
    impl DataRs {
        pub fn new(
            system: SystemState,
            data_a: SingleData,
            data_b: SingleData,
            grid: Grid,
            interactions: Interactions,
            correlations: Correlations,
            dielectrics: Option<DielectricData>,
        ) -> Self {
            DataRs {
                system,
                data_a,
                data_b,
                grid,
                interactions,
                correlations,
                dielectrics,
            }
        }
    }
    pub struct DataPy {
        temp: f64,
        kt: f64,
        ku: f64,
        amph: f64,
        ns1: usize,
        ns2: usize,
        nsp1: usize,
        nsp2: usize,
        npts: usize,
        radius: f64,
        nlam: usize,
        pub cr: Py<PyArray3<f64>>,
        pub tr: Py<PyArray3<f64>>,
        pub hr: Py<PyArray3<f64>>,
        pub hk: Py<PyArray3<f64>>,
        pub gr: Py<PyArray3<f64>>,
        beta: f64,
        pub ur: Py<PyArray3<f64>>,
        pub u_sr: Py<PyArray3<f64>>,
        pub ur_lr: Py<PyArray3<f64>>,
        pub uk_lr: Py<PyArray3<f64>>,
        pub wk: Py<PyArray3<f64>>,
        pub density: Py<PyArray2<f64>>,
        pub rgrid: Py<PyArray1<f64>>,
        pub kgrid: Py<PyArray1<f64>>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DataPy {
        #[inline]
        fn clone(&self) -> DataPy {
            DataPy {
                temp: ::core::clone::Clone::clone(&self.temp),
                kt: ::core::clone::Clone::clone(&self.kt),
                ku: ::core::clone::Clone::clone(&self.ku),
                amph: ::core::clone::Clone::clone(&self.amph),
                ns1: ::core::clone::Clone::clone(&self.ns1),
                ns2: ::core::clone::Clone::clone(&self.ns2),
                nsp1: ::core::clone::Clone::clone(&self.nsp1),
                nsp2: ::core::clone::Clone::clone(&self.nsp2),
                npts: ::core::clone::Clone::clone(&self.npts),
                radius: ::core::clone::Clone::clone(&self.radius),
                nlam: ::core::clone::Clone::clone(&self.nlam),
                cr: ::core::clone::Clone::clone(&self.cr),
                tr: ::core::clone::Clone::clone(&self.tr),
                hr: ::core::clone::Clone::clone(&self.hr),
                hk: ::core::clone::Clone::clone(&self.hk),
                gr: ::core::clone::Clone::clone(&self.gr),
                beta: ::core::clone::Clone::clone(&self.beta),
                ur: ::core::clone::Clone::clone(&self.ur),
                u_sr: ::core::clone::Clone::clone(&self.u_sr),
                ur_lr: ::core::clone::Clone::clone(&self.ur_lr),
                uk_lr: ::core::clone::Clone::clone(&self.uk_lr),
                wk: ::core::clone::Clone::clone(&self.wk),
                density: ::core::clone::Clone::clone(&self.density),
                rgrid: ::core::clone::Clone::clone(&self.rgrid),
                kgrid: ::core::clone::Clone::clone(&self.kgrid),
            }
        }
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        unsafe impl _pyo3::type_object::PyTypeInfo for DataPy {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "DataPy";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <DataPy as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl _pyo3::PyClass for DataPy {
            type Frozen = _pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a DataPy {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, DataPy>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut DataPy {
            type Holder = ::std::option::Option<_pyo3::PyRefMut<'py, DataPy>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl _pyo3::IntoPy<_pyo3::PyObject> for DataPy {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for DataPy {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type Layout = _pyo3::PyCell<Self>;
            type BaseType = _pyo3::PyAny;
            type ThreadChecker = _pyo3::impl_::pyclass::ThreadCheckerStub<DataPy>;
            type PyClassMutability = <<_pyo3::PyAny as _pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as _pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = _pyo3::PyAny;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "temp\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_temp__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "temp\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_temp__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "kt\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_kt__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "kt\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_kt__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "ku\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_ku__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "ku\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_ku__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "amph\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_amph__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "amph\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_amph__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "ns1\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_ns1__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "ns1\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_ns1__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "ns2\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_ns2__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "ns2\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_ns2__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "nsp1\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_nsp1__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "nsp1\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_nsp1__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "nsp2\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_nsp2__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "nsp2\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_nsp2__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "npts\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_npts__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "npts\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_npts__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "radius\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_radius__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "radius\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_radius__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "nlam\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_nlam__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "nlam\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_nlam__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "cr\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_cr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "cr\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_cr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "tr\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_tr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "tr\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_tr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "hr\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_hr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "hr\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_hr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "hk\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_hk__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "hk\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_hk__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "gr\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_gr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "gr\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_gr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "beta\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_beta__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "beta\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_beta__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "ur\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_ur__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "ur\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_ur__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "u_sr\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_u_sr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "u_sr\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_u_sr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "ur_lr\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_ur_lr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "ur_lr\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_ur_lr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "uk_lr\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_uk_lr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "uk_lr\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_uk_lr__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "wk\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_wk__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "wk\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_wk__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "density\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_density__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "density\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_density__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "rgrid\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_rgrid__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "rgrid\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_rgrid__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Getter({
                            _pyo3::class::PyGetterDef::new(
                                "kgrid\0",
                                _pyo3::impl_::pymethods::PyGetter(
                                    DataPy::__pymethod_get_kgrid__,
                                ),
                                "\0",
                            )
                        }),
                        _pyo3::class::PyMethodDefType::Setter({
                            _pyo3::class::PySetterDef::new(
                                "kgrid\0",
                                _pyo3::impl_::pymethods::PySetter(
                                    DataPy::__pymethod_set_kgrid__,
                                ),
                                "\0",
                            )
                        }),
                    ],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <DataPy as _pyo3::PyTypeInfo>::NAME,
                                "\0",
                                ::std::option::Option::None
                                    .or_else(|| collector.new_text_signature()),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<DataPy> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl DataPy {
            unsafe fn __pymethod_get_temp__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .temp),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_temp__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .temp = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_kt__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .kt),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_kt__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .kt = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_ku__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .ku),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_ku__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .ku = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_amph__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .amph),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_amph__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .amph = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_ns1__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .ns1),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_ns1__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .ns1 = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_ns2__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .ns2),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_ns2__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .ns2 = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_nsp1__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .nsp1),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_nsp1__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .nsp1 = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_nsp2__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .nsp2),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_nsp2__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .nsp2 = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_npts__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .npts),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_npts__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .npts = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_radius__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .radius),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_radius__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .radius = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_nlam__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .nlam),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_nlam__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .nlam = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_cr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .cr),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_cr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .cr = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_tr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .tr),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_tr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .tr = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_hr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .hr),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_hr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .hr = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_hk__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .hk),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_hk__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .hk = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_gr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .gr),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_gr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .gr = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_beta__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .beta),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_beta__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .beta = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_ur__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .ur),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_ur__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .ur = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_u_sr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .u_sr),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_u_sr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .u_sr = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_ur_lr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .ur_lr),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_ur_lr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .ur_lr = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_uk_lr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .uk_lr),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_uk_lr__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .uk_lr = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_wk__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .wk),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_wk__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .wk = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_density__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .density),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_density__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .density = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_rgrid__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .rgrid),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_rgrid__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .rgrid = _val;
                    },
                )
            }
            unsafe fn __pymethod_get_kgrid__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        ::std::clone::Clone::clone(
                            &(_pyo3::impl_::extract_argument::extract_pyclass_ref::<
                                DataPy,
                            >(
                                    py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                    &mut {
                                        _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                    },
                                )?
                                .kgrid),
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_set_kgrid__(
                py: _pyo3::Python<'_>,
                _slf: *mut _pyo3::ffi::PyObject,
                _value: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<::std::os::raw::c_int> {
                let _value = py
                    .from_borrowed_ptr_or_opt(_value)
                    .ok_or_else(|| {
                        _pyo3::exceptions::PyAttributeError::new_err(
                            "can't delete attribute",
                        )
                    })?;
                let _val = _pyo3::FromPyObject::extract(_value)?;
                _pyo3::callback::convert(
                    py,
                    {
                        _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                            DataPy,
                        >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?
                            .kgrid = _val;
                    },
                )
            }
        }
    };
    impl DataPy {
        fn new(
            temp: f64,
            kt: f64,
            ku: f64,
            amph: f64,
            ns1: usize,
            ns2: usize,
            nsp1: usize,
            nsp2: usize,
            npts: usize,
            radius: f64,
            nlam: usize,
            cr: Py<PyArray3<f64>>,
            tr: Py<PyArray3<f64>>,
            hr: Py<PyArray3<f64>>,
            hk: Py<PyArray3<f64>>,
            gr: Py<PyArray3<f64>>,
            beta: f64,
            ur: Py<PyArray3<f64>>,
            u_sr: Py<PyArray3<f64>>,
            ur_lr: Py<PyArray3<f64>>,
            uk_lr: Py<PyArray3<f64>>,
            wk: Py<PyArray3<f64>>,
            density: Py<PyArray2<f64>>,
            rgrid: Py<PyArray1<f64>>,
            kgrid: Py<PyArray1<f64>>,
        ) -> Self {
            DataPy {
                temp,
                kt,
                ku,
                amph,
                ns1,
                ns2,
                nsp1,
                nsp2,
                npts,
                radius,
                nlam,
                cr,
                tr,
                hr,
                hk,
                gr,
                beta,
                ur,
                u_sr,
                ur_lr,
                uk_lr,
                wk,
                density,
                rgrid,
                kgrid,
            }
        }
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        impl _pyo3::impl_::pyclass::PyMethods<DataPy>
        for _pyo3::impl_::pyclass::PyClassImplCollector<DataPy> {
            fn py_methods(self) -> &'static _pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: _pyo3::impl_::pyclass::PyClassItems = _pyo3::impl_::pyclass::PyClassItems {
                    methods: &[],
                    slots: &[
                        _pyo3::ffi::PyType_Slot {
                            slot: _pyo3::ffi::Py_tp_new,
                            pfunc: {
                                unsafe extern "C" fn trampoline(
                                    subtype: *mut _pyo3::ffi::PyTypeObject,
                                    args: *mut _pyo3::ffi::PyObject,
                                    kwargs: *mut _pyo3::ffi::PyObject,
                                ) -> *mut _pyo3::ffi::PyObject {
                                    use _pyo3::impl_::pyclass::*;
                                    impl PyClassNewTextSignature<DataPy>
                                    for PyClassImplCollector<DataPy> {
                                        #[inline]
                                        fn new_text_signature(
                                            self,
                                        ) -> ::std::option::Option<&'static str> {
                                            ::std::option::Option::Some(
                                                "(temp, kt, ku, amph, ns1, ns2, nsp1, nsp2, npts, radius, nlam, cr, tr, hr, hk, gr, beta, ur, u_sr, ur_lr, uk_lr, wk, density, rgrid, kgrid)",
                                            )
                                        }
                                    }
                                    _pyo3::impl_::trampoline::newfunc(
                                        subtype,
                                        args,
                                        kwargs,
                                        DataPy::__pymethod___new____,
                                    )
                                }
                                trampoline
                            } as _pyo3::ffi::newfunc as _,
                        },
                    ],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl DataPy {
            unsafe fn __pymethod___new____(
                py: _pyo3::Python<'_>,
                subtype: *mut _pyo3::ffi::PyTypeObject,
                _args: *mut _pyo3::ffi::PyObject,
                _kwargs: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                use _pyo3::callback::IntoPyCallbackOutput;
                let function = DataPy::new;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription = _pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::Some(
                        <DataPy as _pyo3::type_object::PyTypeInfo>::NAME,
                    ),
                    func_name: "__new__",
                    positional_parameter_names: &[
                        "temp",
                        "kt",
                        "ku",
                        "amph",
                        "ns1",
                        "ns2",
                        "nsp1",
                        "nsp2",
                        "npts",
                        "radius",
                        "nlam",
                        "cr",
                        "tr",
                        "hr",
                        "hk",
                        "gr",
                        "beta",
                        "ur",
                        "u_sr",
                        "ur_lr",
                        "uk_lr",
                        "wk",
                        "density",
                        "rgrid",
                        "kgrid",
                    ],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 25usize,
                    keyword_only_parameters: &[],
                };
                let mut output = [::std::option::Option::None; 25usize];
                let (_args, _kwargs) = DESCRIPTION
                    .extract_arguments_tuple_dict::<
                        _pyo3::impl_::extract_argument::NoVarargs,
                        _pyo3::impl_::extract_argument::NoVarkeywords,
                    >(py, _args, _kwargs, &mut output)?;
                let result = DataPy::new(
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "temp",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "kt",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[2usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "ku",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[3usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "amph",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[4usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "ns1",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[5usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "ns2",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[6usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "nsp1",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[7usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "nsp2",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[8usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "npts",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[9usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "radius",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[10usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "nlam",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[11usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "cr",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[12usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "tr",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[13usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "hr",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[14usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "hk",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[15usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "gr",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[16usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "beta",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[17usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "ur",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[18usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "u_sr",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[19usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "ur_lr",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[20usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "uk_lr",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[21usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "wk",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[22usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "density",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[23usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "rgrid",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[24usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "kgrid",
                    )?,
                );
                let initializer: _pyo3::PyClassInitializer<DataPy> = result.convert(py)?;
                let cell = initializer.create_cell_from_subtype(py, subtype)?;
                ::std::result::Result::Ok(cell as *mut _pyo3::ffi::PyObject)
            }
        }
    };
}
pub mod dipole {
    use crate::data::{Site, Species};
    use crate::quaternion::{cross_product, Quaternion};
    use ndarray::{arr1, s, Array, Array1, Array2};
    use ndarray_linalg::{Eigh, IntoTriangular, UPLO};
    use std::cmp::{max, min};
    use std::f64::consts::PI;
    use std::fmt;
    pub struct DipoleError;
    #[automatically_derived]
    impl ::core::fmt::Debug for DipoleError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "DipoleError")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DipoleError {
        #[inline]
        fn clone(&self) -> DipoleError {
            DipoleError
        }
    }
    impl fmt::Display for DipoleError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(format_args!("0 dipole moment for current system"))
        }
    }
    pub fn total_charge_species(species: &[Species]) -> f64 {
        species
            .iter()
            .fold(
                0.0,
                |acc, x| {
                    acc
                        + x
                            .atom_sites
                            .iter()
                            .fold(
                                0.0,
                                |acc_inner, y| acc_inner + y.params.last().unwrap(),
                            )
                },
            )
    }
    #[inline(always)]
    pub fn total_charge(atoms: &[Site]) -> f64 {
        atoms.iter().fold(0.0, |acc, x| acc + x.params.last().unwrap().abs())
    }
    pub fn centre_of_charge_species(species: &[Species]) -> Array1<f64> {
        species
            .iter()
            .fold(
                Array::zeros(3),
                |acc: Array1<f64>, x| {
                    acc
                        + x
                            .atom_sites
                            .iter()
                            .fold(
                                Array::zeros(3),
                                |acc_inner: Array1<f64>, y| {
                                    acc_inner
                                        + (Array::from_shape_vec(3, y.coords.clone()).unwrap()
                                            * y.params.last().unwrap().abs())
                                },
                            )
                },
            )
    }
    #[inline(always)]
    pub fn centre_of_charge(atoms: &[Site]) -> Array1<f64> {
        atoms
            .iter()
            .fold(
                Array::zeros(3),
                |acc, x| {
                    acc
                        + (Array::from_shape_vec(3, x.coords.clone()).unwrap()
                            * x.params.last().unwrap().abs())
                },
            )
    }
    #[inline(always)]
    pub fn translate(atoms: &mut [Site], coords: &Array1<f64>) {
        for site in atoms.iter_mut() {
            let site_coords = Array::from_iter(site.coords.clone().into_iter());
            let new_coords = site_coords - coords;
            site.coords = new_coords.to_vec();
        }
    }
    pub fn dipole_moment(atoms: &[Site]) -> Result<(Array1<f64>, f64), DipoleError> {
        let dmvec = atoms
            .iter()
            .fold(
                Array::zeros(3),
                |acc_inner: Array1<f64>, y| {
                    acc_inner
                        + (Array::from_shape_vec(3, y.coords.clone()).unwrap()
                            * *y.params.last().unwrap())
                },
            );
        let dm = dmvec.mapv(|x| x.powf(2.0)).sum().sqrt();
        match dm < 1e-16 {
            true => Err(DipoleError),
            _ => Ok((dmvec, dm)),
        }
    }
    pub fn reorient(atoms: &mut [Site]) -> Result<(), DipoleError> {
        let (dmvec, dm) = dipole_moment(atoms)?;
        let rdmdm = &dmvec / dm;
        let xaxis = arr1(&[1.0, 0.0, 0.0]);
        let yaxis = arr1(&[0.0, 1.0, 0.0]);
        let zaxis = arr1(&[0.0, 0.0, 1.0]);
        let rotvec = cross_product(&zaxis, &rdmdm);
        let checkvec = cross_product(&rotvec, &rdmdm);
        let angle = rdmdm.dot(&zaxis).acos().copysign(checkvec.dot(&zaxis));
        let quat = Quaternion::from_axis_angle(angle, &rotvec);
        for site in atoms.iter_mut() {
            let site_coords = Array::from_iter(site.coords.clone().into_iter());
            let new_coords = quat.rotate(&site_coords);
            site.coords = new_coords.to_vec();
        }
        let mut temp_atoms = atoms.to_owned().clone();
        for site in temp_atoms.iter_mut() {
            site
                .coords = <[_]>::into_vec(
                #[rustc_box]
                ::alloc::boxed::Box::new([site.coords[0], site.coords[1], 0.0]),
            );
        }
        let moi_matrix = moment_of_inertia(&temp_atoms);
        let (_, mut principal_axes) = moi_matrix
            .into_triangular(UPLO::Upper)
            .eigh(UPLO::Upper)
            .expect("eigendecomposition of moment of inertia matrix");
        let x_pa: Array1<f64> = principal_axes
            .slice(
                match 0..3 {
                    r => {
                        match 0 {
                            r => {
                                let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                    &r,
                                    ::ndarray::SliceNextDim::next_in_dim(
                                        &r,
                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                    ),
                                );
                                let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                    &r,
                                    ::ndarray::SliceNextDim::next_out_dim(
                                        &r,
                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                    ),
                                );
                                #[allow(unsafe_code)]
                                unsafe {
                                    ::ndarray::SliceInfo::new_unchecked(
                                        [
                                            <::ndarray::SliceInfoElem as ::core::convert::From<
                                                _,
                                            >>::from(r),
                                            <::ndarray::SliceInfoElem as ::core::convert::From<
                                                _,
                                            >>::from(r),
                                        ],
                                        in_dim,
                                        out_dim,
                                    )
                                }
                            }
                        }
                    }
                },
            )
            .to_owned();
        let mut x_angle = (f64::min(1.0, f64::max(-1.0, x_pa.dot(&xaxis)))).acos();
        let dir: Array1<f64>;
        if x_angle < (PI - 1e-6) && x_angle > (-PI + 1e-6) {
            dir = cross_product(&x_pa, &xaxis);
        } else {
            dir = yaxis.clone();
        }
        let x_checkvec = cross_product(&dir, &x_pa);
        if x_checkvec.dot(&xaxis).is_sign_negative() {
            x_angle = -x_angle;
        }
        let pa_x_quat = Quaternion::from_axis_angle(x_angle, &dir);
        for site in temp_atoms.iter_mut() {
            let site_coords = Array::from_iter(site.coords.clone().into_iter());
            let new_coords = pa_x_quat.rotate(&site_coords);
            site.coords = new_coords.to_vec();
        }
        for i in 0..3 {
            let pa_slice = principal_axes
                .slice(
                    match 0..3 {
                        r => {
                            match i {
                                r => {
                                    let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                        &r,
                                        ::ndarray::SliceNextDim::next_in_dim(
                                            &r,
                                            ::core::marker::PhantomData::<::ndarray::Ix0>,
                                        ),
                                    );
                                    let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                        &r,
                                        ::ndarray::SliceNextDim::next_out_dim(
                                            &r,
                                            ::core::marker::PhantomData::<::ndarray::Ix0>,
                                        ),
                                    );
                                    #[allow(unsafe_code)]
                                    unsafe {
                                        ::ndarray::SliceInfo::new_unchecked(
                                            [
                                                <::ndarray::SliceInfoElem as ::core::convert::From<
                                                    _,
                                                >>::from(r),
                                                <::ndarray::SliceInfoElem as ::core::convert::From<
                                                    _,
                                                >>::from(r),
                                            ],
                                            in_dim,
                                            out_dim,
                                        )
                                    }
                                }
                            }
                        }
                    },
                )
                .clone()
                .to_owned();
            principal_axes
                .slice_mut(
                    match 0..3 {
                        r => {
                            match i {
                                r => {
                                    let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                        &r,
                                        ::ndarray::SliceNextDim::next_in_dim(
                                            &r,
                                            ::core::marker::PhantomData::<::ndarray::Ix0>,
                                        ),
                                    );
                                    let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                        &r,
                                        ::ndarray::SliceNextDim::next_out_dim(
                                            &r,
                                            ::core::marker::PhantomData::<::ndarray::Ix0>,
                                        ),
                                    );
                                    #[allow(unsafe_code)]
                                    unsafe {
                                        ::ndarray::SliceInfo::new_unchecked(
                                            [
                                                <::ndarray::SliceInfoElem as ::core::convert::From<
                                                    _,
                                                >>::from(r),
                                                <::ndarray::SliceInfoElem as ::core::convert::From<
                                                    _,
                                                >>::from(r),
                                            ],
                                            in_dim,
                                            out_dim,
                                        )
                                    }
                                }
                            }
                        }
                    },
                )
                .assign(&pa_x_quat.rotate(&pa_slice));
        }
        let y_pa: Array1<f64> = principal_axes
            .slice(
                match 0..3 {
                    r => {
                        match 2 {
                            r => {
                                let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                    &r,
                                    ::ndarray::SliceNextDim::next_in_dim(
                                        &r,
                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                    ),
                                );
                                let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                    &r,
                                    ::ndarray::SliceNextDim::next_out_dim(
                                        &r,
                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                    ),
                                );
                                #[allow(unsafe_code)]
                                unsafe {
                                    ::ndarray::SliceInfo::new_unchecked(
                                        [
                                            <::ndarray::SliceInfoElem as ::core::convert::From<
                                                _,
                                            >>::from(r),
                                            <::ndarray::SliceInfoElem as ::core::convert::From<
                                                _,
                                            >>::from(r),
                                        ],
                                        in_dim,
                                        out_dim,
                                    )
                                }
                            }
                        }
                    }
                },
            )
            .to_owned();
        let mut y_angle = (f64::min(1.0, f64::max(-1.0, y_pa.dot(&yaxis)))).acos();
        let y_checkvec = cross_product(&xaxis, &y_pa);
        if y_checkvec.dot(&yaxis).is_sign_negative() {
            y_angle = -y_angle;
        }
        let pa_y_quat = Quaternion::from_axis_angle(y_angle, &xaxis);
        for site in temp_atoms.iter_mut() {
            let site_coords = Array::from_iter(site.coords.clone().into_iter());
            let new_coords = pa_y_quat.rotate(&site_coords);
            site.coords = new_coords.to_vec();
        }
        for i in 0..3 {
            let pa_slice = principal_axes
                .slice(
                    match 0..3 {
                        r => {
                            match i {
                                r => {
                                    let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                        &r,
                                        ::ndarray::SliceNextDim::next_in_dim(
                                            &r,
                                            ::core::marker::PhantomData::<::ndarray::Ix0>,
                                        ),
                                    );
                                    let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                        &r,
                                        ::ndarray::SliceNextDim::next_out_dim(
                                            &r,
                                            ::core::marker::PhantomData::<::ndarray::Ix0>,
                                        ),
                                    );
                                    #[allow(unsafe_code)]
                                    unsafe {
                                        ::ndarray::SliceInfo::new_unchecked(
                                            [
                                                <::ndarray::SliceInfoElem as ::core::convert::From<
                                                    _,
                                                >>::from(r),
                                                <::ndarray::SliceInfoElem as ::core::convert::From<
                                                    _,
                                                >>::from(r),
                                            ],
                                            in_dim,
                                            out_dim,
                                        )
                                    }
                                }
                            }
                        }
                    },
                )
                .clone()
                .to_owned();
            principal_axes
                .slice_mut(
                    match 0..3 {
                        r => {
                            match i {
                                r => {
                                    let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                        &r,
                                        ::ndarray::SliceNextDim::next_in_dim(
                                            &r,
                                            ::core::marker::PhantomData::<::ndarray::Ix0>,
                                        ),
                                    );
                                    let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                        &r,
                                        ::ndarray::SliceNextDim::next_out_dim(
                                            &r,
                                            ::core::marker::PhantomData::<::ndarray::Ix0>,
                                        ),
                                    );
                                    #[allow(unsafe_code)]
                                    unsafe {
                                        ::ndarray::SliceInfo::new_unchecked(
                                            [
                                                <::ndarray::SliceInfoElem as ::core::convert::From<
                                                    _,
                                                >>::from(r),
                                                <::ndarray::SliceInfoElem as ::core::convert::From<
                                                    _,
                                                >>::from(r),
                                            ],
                                            in_dim,
                                            out_dim,
                                        )
                                    }
                                }
                            }
                        }
                    },
                )
                .assign(&pa_y_quat.rotate(&pa_slice));
        }
        for (origin_site, temp_site) in atoms.iter_mut().zip(temp_atoms.iter()) {
            origin_site.coords[0] = temp_site.coords[0];
            origin_site.coords[1] = temp_site.coords[1];
        }
        Ok(())
    }
    #[inline(always)]
    fn moment_of_inertia(atoms: &[Site]) -> Array2<f64> {
        let mut out_arr = Array::zeros((3, 3));
        let charges = Array::from_shape_vec(
                atoms.len(),
                atoms.iter().map(|atom| atom.params.last().unwrap()).collect(),
            )
            .unwrap();
        for (i, iat) in atoms.iter().enumerate() {
            let ci = charges[[i]].abs();
            out_arr[[0, 0]]
                += ci * iat.coords[1] * iat.coords[1] + iat.coords[2] * iat.coords[2];
            out_arr[[1, 1]]
                += ci * iat.coords[0] * iat.coords[0] + iat.coords[2] * iat.coords[2];
            out_arr[[2, 2]]
                += ci * iat.coords[1] * iat.coords[1] + iat.coords[0] * iat.coords[0];
            out_arr[[0, 1]] -= ci * iat.coords[0] * iat.coords[1];
            out_arr[[0, 2]] -= ci * iat.coords[0] * iat.coords[2];
            out_arr[[1, 2]] -= ci * iat.coords[1] * iat.coords[2];
        }
        out_arr[[1, 0]] = out_arr[[0, 1]];
        out_arr[[2, 0]] = out_arr[[0, 2]];
        out_arr[[2, 1]] = out_arr[[2, 1]];
        out_arr
    }
    pub fn dmtodebye(dm: f64) -> f64 {
        dm * 1.60217663e-29 * 2.997924581780902e29
    }
}
pub mod driver {
    use crate::data::{
        Correlations, DataConfig, DataRs, DielectricData, Grid, Interactions, SingleData,
        Species, SystemState,
    };
    use crate::dipole::*;
    use crate::integralequation::IntegralEquationKind;
    use crate::operator::{Operator, OperatorConfig};
    use crate::potential::{Potential, PotentialConfig};
    use crate::solver::Solver;
    use crate::solver::SolverConfig;
    use log::{debug, error, info, warn};
    use ndarray::{Array, Array1, Array2, Array3, Axis, Zip};
    use pyo3::prelude::*;
    use std::f64::consts::PI;
    pub enum Verbosity {
        Quiet,
        Warning,
        Info,
        Debug,
        Trace,
    }
    pub struct RISMDriver {
        pub solvent: SingleData,
        pub solute: Option<SingleData>,
        pub data: DataConfig,
        pub operator: OperatorConfig,
        pub potential: PotentialConfig,
        pub solver: SolverConfig,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for RISMDriver {
        #[inline]
        fn clone(&self) -> RISMDriver {
            RISMDriver {
                solvent: ::core::clone::Clone::clone(&self.solvent),
                solute: ::core::clone::Clone::clone(&self.solute),
                data: ::core::clone::Clone::clone(&self.data),
                operator: ::core::clone::Clone::clone(&self.operator),
                potential: ::core::clone::Clone::clone(&self.potential),
                solver: ::core::clone::Clone::clone(&self.solver),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for RISMDriver {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "solvent",
                "solute",
                "data",
                "operator",
                "potential",
                "solver",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.solvent,
                &self.solute,
                &self.data,
                &self.operator,
                &self.potential,
                &&self.solver,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(
                f,
                "RISMDriver",
                names,
                values,
            )
        }
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        unsafe impl _pyo3::type_object::PyTypeInfo for RISMDriver {
            type AsRefTarget = _pyo3::PyCell<Self>;
            const NAME: &'static str = "RISMDriver";
            const MODULE: ::std::option::Option<&'static str> = ::core::option::Option::None;
            #[inline]
            fn type_object_raw(py: _pyo3::Python<'_>) -> *mut _pyo3::ffi::PyTypeObject {
                <RISMDriver as _pyo3::impl_::pyclass::PyClassImpl>::lazy_type_object()
                    .get_or_init(py)
                    .as_type_ptr()
            }
        }
        impl _pyo3::PyClass for RISMDriver {
            type Frozen = _pyo3::pyclass::boolean_struct::False;
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a RISMDriver {
            type Holder = ::std::option::Option<_pyo3::PyRef<'py, RISMDriver>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref(obj, holder)
            }
        }
        impl<'a, 'py> _pyo3::impl_::extract_argument::PyFunctionArgument<'a, 'py>
        for &'a mut RISMDriver {
            type Holder = ::std::option::Option<_pyo3::PyRefMut<'py, RISMDriver>>;
            #[inline]
            fn extract(
                obj: &'py _pyo3::PyAny,
                holder: &'a mut Self::Holder,
            ) -> _pyo3::PyResult<Self> {
                _pyo3::impl_::extract_argument::extract_pyclass_ref_mut(obj, holder)
            }
        }
        impl _pyo3::IntoPy<_pyo3::PyObject> for RISMDriver {
            fn into_py(self, py: _pyo3::Python) -> _pyo3::PyObject {
                _pyo3::IntoPy::into_py(_pyo3::Py::new(py, self).unwrap(), py)
            }
        }
        impl _pyo3::impl_::pyclass::PyClassImpl for RISMDriver {
            const IS_BASETYPE: bool = false;
            const IS_SUBCLASS: bool = false;
            const IS_MAPPING: bool = false;
            const IS_SEQUENCE: bool = false;
            type Layout = _pyo3::PyCell<Self>;
            type BaseType = _pyo3::PyAny;
            type ThreadChecker = _pyo3::impl_::pyclass::ThreadCheckerStub<RISMDriver>;
            type PyClassMutability = <<_pyo3::PyAny as _pyo3::impl_::pyclass::PyClassBaseType>::PyClassMutability as _pyo3::impl_::pycell::PyClassMutability>::MutableChild;
            type Dict = _pyo3::impl_::pyclass::PyClassDummySlot;
            type WeakRef = _pyo3::impl_::pyclass::PyClassDummySlot;
            type BaseNativeType = _pyo3::PyAny;
            fn items_iter() -> _pyo3::impl_::pyclass::PyClassItemsIter {
                use _pyo3::impl_::pyclass::*;
                let collector = PyClassImplCollector::<Self>::new();
                static INTRINSIC_ITEMS: PyClassItems = PyClassItems {
                    methods: &[],
                    slots: &[],
                };
                PyClassItemsIter::new(&INTRINSIC_ITEMS, collector.py_methods())
            }
            fn doc(py: _pyo3::Python<'_>) -> _pyo3::PyResult<&'static ::std::ffi::CStr> {
                use _pyo3::impl_::pyclass::*;
                static DOC: _pyo3::once_cell::GILOnceCell<
                    ::std::borrow::Cow<'static, ::std::ffi::CStr>,
                > = _pyo3::once_cell::GILOnceCell::new();
                DOC.get_or_try_init(
                        py,
                        || {
                            let collector = PyClassImplCollector::<Self>::new();
                            build_pyclass_doc(
                                <RISMDriver as _pyo3::PyTypeInfo>::NAME,
                                "\0",
                                ::std::option::Option::None
                                    .or_else(|| collector.new_text_signature()),
                            )
                        },
                    )
                    .map(::std::ops::Deref::deref)
            }
            fn lazy_type_object() -> &'static _pyo3::impl_::pyclass::LazyTypeObject<
                Self,
            > {
                use _pyo3::impl_::pyclass::LazyTypeObject;
                static TYPE_OBJECT: LazyTypeObject<RISMDriver> = LazyTypeObject::new();
                &TYPE_OBJECT
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl RISMDriver {}
    };
    impl RISMDriver {
        fn new<'py>(
            data_config: &PyAny,
            operator_config: &PyAny,
            potential_config: &PyAny,
            solver_config: &PyAny,
        ) -> PyResult<Self> {
            let data: DataConfig = data_config.extract()?;
            let (solvent, solute);
            let shape = (data.npts, data.nsv, data.nsv);
            solvent = SingleData::new(
                data.solvent_atoms.clone(),
                data.solvent_species.clone(),
                shape,
            );
            match data.nsu {
                None => solute = None,
                _ => {
                    let shape = (data.npts, data.nsu.unwrap(), data.nsu.unwrap());
                    solute = Some(
                        SingleData::new(
                            data.solute_atoms.as_ref().unwrap().clone(),
                            data.solute_species.as_ref().unwrap().clone(),
                            shape,
                        ),
                    );
                }
            }
            let operator: OperatorConfig = operator_config.extract()?;
            let potential: PotentialConfig = potential_config.extract()?;
            let solver: SolverConfig = solver_config.extract()?;
            Ok(RISMDriver {
                solvent,
                solute,
                data,
                operator,
                potential,
                solver,
            })
        }
        pub fn execute(&mut self) {
            self.print_header();
            simple_logger::init_with_env().unwrap();
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("Defining operator"),
                        lvl,
                        &("librism::driver", "librism::driver", "src/driver.rs"),
                        93u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            let operator = Operator::new(&self.operator);
            let operator_uv = Operator::new(
                &OperatorConfig {
                    integral_equation: IntegralEquationKind::UV,
                    ..self.operator.clone()
                },
            );
            let (mut vv, uv) = self.problem_setup();
            let mut solver = self.solver.solver.set(&self.solver.settings);
            match solver.solve(&mut vv, &operator) {
                Ok(()) => {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("Finished!"),
                            lvl,
                            &("librism::driver", "librism::driver", "src/driver.rs"),
                            105u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
                Err(e) => {
                    let lvl = ::log::Level::Error;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("{0}", e),
                            lvl,
                            &("librism::driver", "librism::driver", "src/driver.rs"),
                            106u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
            }
            match uv {
                None => {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("No solute-solvent problem"),
                            lvl,
                            &("librism::driver", "librism::driver", "src/driver.rs"),
                            110u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
                Some(mut uv) => {
                    match solver.solve(&mut uv, &operator_uv) {
                        Ok(()) => {
                            let lvl = ::log::Level::Info;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!("Finished"),
                                    lvl,
                                    &("librism::driver", "librism::driver", "src/driver.rs"),
                                    112u32,
                                    ::log::__private_api::Option::None,
                                );
                            }
                        }
                        Err(e) => {
                            ::core::panicking::panic_display(&e);
                        }
                    }
                }
            }
        }
        fn do_rism(&mut self) {
            ::core::panicking::panic("not yet implemented")
        }
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        impl _pyo3::impl_::pyclass::PyMethods<RISMDriver>
        for _pyo3::impl_::pyclass::PyClassImplCollector<RISMDriver> {
            fn py_methods(self) -> &'static _pyo3::impl_::pyclass::PyClassItems {
                static ITEMS: _pyo3::impl_::pyclass::PyClassItems = _pyo3::impl_::pyclass::PyClassItems {
                    methods: &[
                        _pyo3::class::PyMethodDefType::Method(
                            _pyo3::impl_::pymethods::PyMethodDef::noargs(
                                "execute\0",
                                _pyo3::impl_::pymethods::PyCFunction({
                                    unsafe extern "C" fn trampoline(
                                        _slf: *mut _pyo3::ffi::PyObject,
                                        _args: *mut _pyo3::ffi::PyObject,
                                    ) -> *mut _pyo3::ffi::PyObject {
                                        _pyo3::impl_::trampoline::noargs(
                                            _slf,
                                            _args,
                                            RISMDriver::__pymethod_execute__,
                                        )
                                    }
                                    trampoline
                                }),
                                "execute($self)\n--\n\n\0",
                            ),
                        ),
                        _pyo3::class::PyMethodDefType::Method(
                            _pyo3::impl_::pymethods::PyMethodDef::noargs(
                                "do_rism\0",
                                _pyo3::impl_::pymethods::PyCFunction({
                                    unsafe extern "C" fn trampoline(
                                        _slf: *mut _pyo3::ffi::PyObject,
                                        _args: *mut _pyo3::ffi::PyObject,
                                    ) -> *mut _pyo3::ffi::PyObject {
                                        _pyo3::impl_::trampoline::noargs(
                                            _slf,
                                            _args,
                                            RISMDriver::__pymethod_do_rism__,
                                        )
                                    }
                                    trampoline
                                }),
                                "do_rism($self)\n--\n\n\0",
                            ),
                        ),
                    ],
                    slots: &[
                        _pyo3::ffi::PyType_Slot {
                            slot: _pyo3::ffi::Py_tp_new,
                            pfunc: {
                                unsafe extern "C" fn trampoline(
                                    subtype: *mut _pyo3::ffi::PyTypeObject,
                                    args: *mut _pyo3::ffi::PyObject,
                                    kwargs: *mut _pyo3::ffi::PyObject,
                                ) -> *mut _pyo3::ffi::PyObject {
                                    use _pyo3::impl_::pyclass::*;
                                    impl PyClassNewTextSignature<RISMDriver>
                                    for PyClassImplCollector<RISMDriver> {
                                        #[inline]
                                        fn new_text_signature(
                                            self,
                                        ) -> ::std::option::Option<&'static str> {
                                            ::std::option::Option::Some(
                                                "(data_config, operator_config, potential_config, solver_config)",
                                            )
                                        }
                                    }
                                    _pyo3::impl_::trampoline::newfunc(
                                        subtype,
                                        args,
                                        kwargs,
                                        RISMDriver::__pymethod___new____,
                                    )
                                }
                                trampoline
                            } as _pyo3::ffi::newfunc as _,
                        },
                    ],
                };
                &ITEMS
            }
        }
        #[doc(hidden)]
        #[allow(non_snake_case)]
        impl RISMDriver {
            unsafe fn __pymethod___new____(
                py: _pyo3::Python<'_>,
                subtype: *mut _pyo3::ffi::PyTypeObject,
                _args: *mut _pyo3::ffi::PyObject,
                _kwargs: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                use _pyo3::callback::IntoPyCallbackOutput;
                let function = RISMDriver::new;
                const DESCRIPTION: _pyo3::impl_::extract_argument::FunctionDescription = _pyo3::impl_::extract_argument::FunctionDescription {
                    cls_name: ::std::option::Option::Some(
                        <RISMDriver as _pyo3::type_object::PyTypeInfo>::NAME,
                    ),
                    func_name: "__new__",
                    positional_parameter_names: &[
                        "data_config",
                        "operator_config",
                        "potential_config",
                        "solver_config",
                    ],
                    positional_only_parameters: 0usize,
                    required_positional_parameters: 4usize,
                    keyword_only_parameters: &[],
                };
                let mut output = [::std::option::Option::None; 4usize];
                let (_args, _kwargs) = DESCRIPTION
                    .extract_arguments_tuple_dict::<
                        _pyo3::impl_::extract_argument::NoVarargs,
                        _pyo3::impl_::extract_argument::NoVarkeywords,
                    >(py, _args, _kwargs, &mut output)?;
                let result = RISMDriver::new(
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[0usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "data_config",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[1usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "operator_config",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[2usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "potential_config",
                    )?,
                    _pyo3::impl_::extract_argument::extract_argument(
                        _pyo3::impl_::extract_argument::unwrap_required_argument(
                            output[3usize],
                        ),
                        &mut {
                            _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                        },
                        "solver_config",
                    )?,
                );
                let initializer: _pyo3::PyClassInitializer<RISMDriver> = result
                    .convert(py)?;
                let cell = initializer.create_cell_from_subtype(py, subtype)?;
                ::std::result::Result::Ok(cell as *mut _pyo3::ffi::PyObject)
            }
            unsafe fn __pymethod_execute__<'py>(
                py: _pyo3::Python<'py>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                let function = RISMDriver::execute;
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        function(
                            _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                                RISMDriver,
                            >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?,
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
            unsafe fn __pymethod_do_rism__<'py>(
                py: _pyo3::Python<'py>,
                _slf: *mut _pyo3::ffi::PyObject,
            ) -> _pyo3::PyResult<*mut _pyo3::ffi::PyObject> {
                let function = RISMDriver::do_rism;
                _pyo3::impl_::pymethods::OkWrap::wrap(
                        function(
                            _pyo3::impl_::extract_argument::extract_pyclass_ref_mut::<
                                RISMDriver,
                            >(
                                py.from_borrowed_ptr::<_pyo3::PyAny>(_slf),
                                &mut {
                                    _pyo3::impl_::extract_argument::FunctionArgumentHolder::INIT
                                },
                            )?,
                        ),
                        py,
                    )
                    .map_err(::core::convert::Into::into)
                    .map(_pyo3::IntoPyPointer::into_ptr)
            }
        }
    };
    impl RISMDriver {
        fn problem_setup(&mut self) -> (DataRs, Option<DataRs>) {
            let (mut vv_problem, uv_problem);
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("Defining solvent-solvent problem"),
                        lvl,
                        &("librism::driver", "librism::driver", "src/driver.rs"),
                        143u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            let grid = Grid::new(self.data.npts, self.data.radius);
            let system = SystemState::new(
                self.data.temp,
                self.data.kt,
                self.data.amph,
                self.data.nlambda,
            );
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("Checking for dipole moment"),
                        lvl,
                        &("librism::driver", "librism::driver", "src/driver.rs"),
                        151u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            let mut dm_vec = Vec::new();
            for species in self.solvent.species.iter() {
                dm_vec.push(dipole_moment(&species.atom_sites));
            }
            let (dm, _): (Vec<_>, Vec<_>) = dm_vec.into_iter().partition(Result::is_ok);
            if dm.is_empty() {
                {
                    let lvl = ::log::Level::Warn;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("No dipole moment found!"),
                            lvl,
                            &("librism::driver", "librism::driver", "src/driver.rs"),
                            158u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                }
            } else if dm.is_empty()
                && self.operator.integral_equation == IntegralEquationKind::DRISM
            {
                {
                    let lvl = ::log::Level::Warn;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!(
                                "No dipole moment found! Switch from DRISM to XRISM",
                            ),
                            lvl,
                            &("librism::driver", "librism::driver", "src/driver.rs"),
                            160u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                self.operator.integral_equation = IntegralEquationKind::XRISM;
            } else {
                {
                    let lvl = ::log::Level::Info;
                    if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                        ::log::__private_api::log(
                            format_args!("Aligning dipole moment to z-axis"),
                            lvl,
                            &("librism::driver", "librism::driver", "src/driver.rs"),
                            163u32,
                            ::log::__private_api::Option::None,
                        );
                    }
                };
                for species in self.solvent.species.iter_mut() {
                    let tot_charge = total_charge(&species.atom_sites);
                    let mut coc = centre_of_charge(&species.atom_sites);
                    coc /= tot_charge;
                    translate(&mut species.atom_sites, &coc);
                    match reorient(&mut species.atom_sites) {
                        Ok(_) => {}
                        Err(e) => {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "{0}; there should be a dipole moment present for this step, something has gone FATALLY wrong",
                                    e,
                                ),
                            );
                        }
                    }
                }
            }
            let dielectric;
            match self.operator.integral_equation {
                IntegralEquationKind::DRISM => {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Calculating dielectric asymptotics for DRISM",
                                ),
                                lvl,
                                &("librism::driver", "librism::driver", "src/driver.rs"),
                                181u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    let mut k_exp_term = grid.kgrid.clone();
                    let total_density = self
                        .solvent
                        .species
                        .iter()
                        .fold(0.0, |acc, species| acc + species.dens);
                    let drism_damping = self
                        .data
                        .drism_damping
                        .expect("damping parameter for DRISM set");
                    let diel = self.data.dielec.expect("dielectric constant set");
                    k_exp_term
                        .par_mapv_inplace(|x| {
                            (-1.0 * (drism_damping * x / 2.0).powf(2.0)).exp()
                        });
                    let dipole_density = self
                        .solvent
                        .species
                        .iter()
                        .fold(
                            0.0,
                            |acc, species| {
                                match dipole_moment(&species.atom_sites) {
                                    Ok((_, dm)) => acc + species.dens * dm * dm,
                                    _ => acc + 0.0,
                                }
                            },
                        );
                    let y = 4.0 * PI * dipole_density / 9.0;
                    let hc0 = (((diel - 1.0) / y) - 3.0) / total_density;
                    let hck = hc0 * k_exp_term;
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!("y: {0}", y),
                                lvl,
                                &("librism::driver", "librism::driver", "src/driver.rs"),
                                203u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    {
                        let lvl = ::log::Level::Debug;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!("h_c(0): {0}", hc0),
                                lvl,
                                &("librism::driver", "librism::driver", "src/driver.rs"),
                                204u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    let chi = {
                        let mut d0x = Array::zeros(self.data.nsv);
                        let mut d0y = Array::zeros(self.data.nsv);
                        let mut d1z = Array::zeros(self.data.nsv);
                        let mut chi = Array::zeros((
                            self.data.npts,
                            self.data.nsv,
                            self.data.nsv,
                        ));
                        for (ki, k) in grid.kgrid.iter().enumerate() {
                            let mut i = 0;
                            for species in self.solvent.species.iter() {
                                for atm in species.atom_sites.iter() {
                                    let k_coord = *k * Array::from_vec(atm.coords.clone());
                                    if k_coord[0] == 0.0 {
                                        d0x[i] = 1.0
                                    } else {
                                        d0x[i] = (k_coord[0]).sin() / k_coord[0];
                                    }
                                    if k_coord[1] == 0.0 {
                                        d0y[i] = 1.0
                                    } else {
                                        d0y[i] = (k_coord[1]).sin() / k_coord[1];
                                    }
                                    if k_coord[2] == 0.0 {
                                        d1z[i] = 1.0
                                    } else {
                                        d1z[i] = ((k_coord[2].sin() / k_coord[2])
                                            - k_coord[2].cos()) / k_coord[2];
                                    }
                                    i += 1;
                                }
                            }
                            for i in 0..self.data.nsv {
                                for j in 0..self.data.nsv {
                                    chi[[
                                        ki,
                                        i,
                                        j,
                                    ]] = d0x[i] * d0y[i] * d1z[i] * d0x[j] * d0y[j] * d1z[j]
                                        * hck[ki];
                                }
                            }
                        }
                        chi
                    };
                    dielectric = Some(DielectricData::new(drism_damping, diel, chi));
                }
                _ => dielectric = None,
            }
            let interactions = Interactions::new(
                self.data.npts,
                self.data.nsv,
                self.data.nsv,
            );
            let correlations = Correlations::new(
                self.data.npts,
                self.data.nsv,
                self.data.nsv,
            );
            vv_problem = DataRs::new(
                system.clone(),
                self.solvent.clone(),
                self.solvent.clone(),
                grid.clone(),
                interactions,
                correlations,
                dielectric.clone(),
            );
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!("Tabulating solvent-solvent potentials"),
                        lvl,
                        &("librism::driver", "librism::driver", "src/driver.rs"),
                        266u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            self.build_potential(&mut vv_problem);
            {
                let lvl = ::log::Level::Info;
                if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                    ::log::__private_api::log(
                        format_args!(
                            "Tabulating solvent intramolecular correlation functions",
                        ),
                        lvl,
                        &("librism::driver", "librism::driver", "src/driver.rs"),
                        269u32,
                        ::log::__private_api::Option::None,
                    );
                }
            };
            self.build_intramolecular_correlation(&mut vv_problem);
            match &self.solute {
                None => {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!("No solute data"),
                                lvl,
                                &("librism::driver", "librism::driver", "src/driver.rs"),
                                273u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    uv_problem = None;
                }
                Some(solute) => {
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!("Solute data found"),
                                lvl,
                                &("librism::driver", "librism::driver", "src/driver.rs"),
                                277u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    {
                        let lvl = ::log::Level::Warn;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "pyRISM only tested for infinite dilution; setting non-zero solute density may not work",
                                ),
                                lvl,
                                &("librism::driver", "librism::driver", "src/driver.rs"),
                                278u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    let interactions = Interactions::new(
                        self.data.npts,
                        self.data.nsu.unwrap(),
                        self.data.nsv,
                    );
                    let correlations = Correlations::new(
                        self.data.npts,
                        self.data.nsu.unwrap(),
                        self.data.nsv,
                    );
                    let mut uv = DataRs::new(
                        system.clone(),
                        solute.clone(),
                        self.solvent.clone(),
                        grid.clone(),
                        interactions,
                        correlations,
                        dielectric.clone(),
                    );
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!("Tabulating solute-solvent potentials"),
                                lvl,
                                &("librism::driver", "librism::driver", "src/driver.rs"),
                                294u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    self.build_potential(&mut uv);
                    {
                        let lvl = ::log::Level::Info;
                        if lvl <= ::log::STATIC_MAX_LEVEL && lvl <= ::log::max_level() {
                            ::log::__private_api::log(
                                format_args!(
                                    "Tabulating solute intramolecular correlation functions",
                                ),
                                lvl,
                                &("librism::driver", "librism::driver", "src/driver.rs"),
                                297u32,
                                ::log::__private_api::Option::None,
                            );
                        }
                    };
                    self.build_intramolecular_correlation(&mut uv);
                    uv_problem = Some(uv);
                }
            }
            (vv_problem, uv_problem)
        }
        fn print_header(&self) {
            {
                ::std::io::_print(
                    format_args!(
                        "\n             ____  ___ ____  __  __ \n _ __  _   _|  _ \\|_ _/ ___||  \\/  |\n| \'_ \\| | | | |_) || |\\___ \\| |\\/| |\n| |_) | |_| |  _ < | | ___) | |  | |\n| .__/ \\__, |_| \\_\\___|____/|_|  |_|\n|_|    |___/                        \n\n\n",
                    ),
                );
            };
        }
        fn build_potential(&mut self, problem: &mut DataRs) {
            let potential = Potential::new(&self.potential);
            let npts = problem.grid.npts;
            let num_sites_a = problem.data_a.sites.len();
            let num_sites_b = problem.data_b.sites.len();
            let shape = (npts, num_sites_a, num_sites_b);
            let (mut u_nb, mut u_c) = (Array::zeros(shape), Array::zeros(shape));
            (potential
                .nonbonded)(
                &problem.data_a.sites,
                &problem.data_b.sites,
                &problem.grid.rgrid,
                &mut u_nb,
            );
            (potential
                .coulombic)(
                &problem.data_a.sites,
                &problem.data_b.sites,
                &problem.grid.rgrid,
                &mut u_c,
            );
            u_c *= problem.system.amph;
            problem.interactions.ur = u_nb + u_c;
            (potential
                .renormalisation_real)(
                &problem.data_a.sites,
                &problem.data_b.sites,
                &problem.grid.rgrid,
                &mut problem.interactions.ur_lr,
            );
            (potential
                .renormalisation_fourier)(
                &problem.data_a.sites,
                &problem.data_b.sites,
                &problem.grid.kgrid,
                &mut problem.interactions.uk_lr,
            );
            problem.interactions.ur_lr *= problem.system.amph;
            problem.interactions.uk_lr *= problem.system.amph;
            problem
                .interactions
                .u_sr = &problem.interactions.ur - &problem.interactions.ur_lr;
        }
        fn build_intramolecular_correlation(&mut self, problem: &mut DataRs) {
            let distances_a = Self::distance_matrix(
                &problem.data_a.species,
                &problem.data_a.species,
            );
            let distances_b = Self::distance_matrix(
                &problem.data_b.species,
                &problem.data_b.species,
            );
            Self::intramolecular_corr_impl(
                &distances_a,
                &problem.grid.kgrid,
                &mut problem.data_a.wk,
            );
            Self::intramolecular_corr_impl(
                &distances_b,
                &problem.grid.kgrid,
                &mut problem.data_b.wk,
            );
        }
        fn intramolecular_corr_impl(
            distances: &Array2<f64>,
            k: &Array1<f64>,
            out_array: &mut Array3<f64>,
        ) {
            let (npts, _, _) = out_array.dim();
            let one = Array::ones(npts);
            let zero = Array::zeros(npts);
            Zip::from(out_array.lanes_mut(Axis(0)))
                .and(distances)
                .par_for_each(|mut lane, elem| {
                    let elem = *elem;
                    if elem < 0.0 {
                        lane.assign(&zero)
                    } else if elem == 0.0 {
                        lane.assign(&one)
                    } else {
                        let arr = (elem * k).mapv(|a| a.sin()) / (elem * k);
                        lane.assign(&arr)
                    }
                });
        }
        fn distance(a: Array1<f64>, b: Array1<f64>) -> f64 {
            (a - b).mapv(|a| a.powf(2.0)).sum().sqrt()
        }
        fn distance_matrix(species_a: &[Species], species_b: &[Species]) -> Array2<f64> {
            let ns1 = species_a.iter().fold(0, |acc, spec| acc + spec.ns);
            let ns2 = species_b.iter().fold(0, |acc, spec| acc + spec.ns);
            let mut out_mat = Array::zeros((ns1, ns2));
            let mut i = 0;
            for isp in species_a.iter() {
                for iat in isp.atom_sites.iter() {
                    let mut j = 0;
                    for jsp in species_b.iter() {
                        for jat in jsp.atom_sites.iter() {
                            if isp != jsp {
                                out_mat[[i, j]] = -1.0;
                            } else {
                                let dist = Self::distance(
                                    Array::from_shape_vec(3, iat.coords.clone()).unwrap(),
                                    Array::from_shape_vec(3, jat.coords.clone()).unwrap(),
                                );
                                out_mat[[i, j]] = dist;
                            }
                            j += 1;
                        }
                    }
                    i += 1;
                }
            }
            out_mat
        }
    }
}
pub mod integralequation {
    use crate::data::DataRs;
    use crate::transforms::fourier_bessel_transform_fftw;
    use fftw::plan::*;
    use ndarray::{Array, Array2, Array3, ArrayView1, ArrayView2, ArrayView3, Axis, Zip};
    use ndarray_linalg::Inverse;
    use pyo3::{prelude::*, types::PyString};
    use std::f64::consts::PI;
    use std::fmt;
    pub enum IntegralEquationKind {
        XRISM,
        DRISM,
        UV,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for IntegralEquationKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    IntegralEquationKind::XRISM => "XRISM",
                    IntegralEquationKind::DRISM => "DRISM",
                    IntegralEquationKind::UV => "UV",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for IntegralEquationKind {
        #[inline]
        fn clone(&self) -> IntegralEquationKind {
            match self {
                IntegralEquationKind::XRISM => IntegralEquationKind::XRISM,
                IntegralEquationKind::DRISM => IntegralEquationKind::DRISM,
                IntegralEquationKind::UV => IntegralEquationKind::UV,
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for IntegralEquationKind {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for IntegralEquationKind {
        #[inline]
        fn eq(&self, other: &IntegralEquationKind) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    impl<'source> FromPyObject<'source> for IntegralEquationKind {
        fn extract(obj: &'source PyAny) -> PyResult<Self> {
            let str = obj
                .downcast::<PyString>()?
                .to_str()
                .map(ToOwned::to_owned)
                .expect("could not convert string");
            match str.as_str() {
                "XRISM" => Ok(IntegralEquationKind::XRISM),
                "DRISM" => Ok(IntegralEquationKind::DRISM),
                _ => {
                    ::core::panicking::panic_fmt(
                        format_args!("not a valid integral equation"),
                    );
                }
            }
        }
    }
    impl fmt::Display for IntegralEquationKind {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                IntegralEquationKind::XRISM => f.write_fmt(format_args!("Extended RISM")),
                IntegralEquationKind::DRISM => {
                    f.write_fmt(format_args!("Dielectrically Consistent RISM"))
                }
                IntegralEquationKind::UV => {
                    f.write_fmt(format_args!("Solute-Solvent RISM"))
                }
            }
        }
    }
    impl IntegralEquationKind {
        pub fn set(&self) -> fn(&mut DataRs) {
            match self {
                IntegralEquationKind::XRISM => xrism_vv,
                IntegralEquationKind::DRISM => drism_vv,
                IntegralEquationKind::UV => rism_uv,
            }
        }
    }
    pub fn rism_uv(_data: &mut DataRs) {
        ::core::panicking::panic("not yet implemented")
    }
    pub fn xrism_vv(problem: &mut DataRs) {
        let nsv = problem.data_a.sites.len();
        (
            problem.correlations.hk,
            problem.correlations.tr,
        ) = rism_vv_equation_impl(
            nsv,
            problem.grid.npts,
            problem.grid.rgrid.view(),
            problem.grid.kgrid.view(),
            problem.grid.dr,
            problem.grid.dk,
            problem.correlations.cr.view(),
            problem.data_a.wk.view(),
            problem.data_a.density.view(),
            problem.system.beta,
            problem.interactions.uk_lr.view(),
            problem.interactions.ur_lr.view(),
            Array::zeros((problem.grid.npts, nsv, nsv)).view(),
        );
    }
    pub fn drism_vv(problem: &mut DataRs) {
        let nsv = problem.data_a.sites.len();
        (
            problem.correlations.hk,
            problem.correlations.tr,
        ) = rism_vv_equation_impl(
            nsv,
            problem.grid.npts,
            problem.grid.rgrid.view(),
            problem.grid.kgrid.view(),
            problem.grid.dr,
            problem.grid.dk,
            problem.correlations.cr.view(),
            problem.data_a.wk.view(),
            problem.data_a.density.view(),
            problem.system.beta,
            problem.interactions.uk_lr.view(),
            problem.interactions.ur_lr.view(),
            problem.dielectrics.as_ref().unwrap().chi.view(),
        );
    }
    fn rism_vv_equation_impl(
        nsv: usize,
        _npts: usize,
        r: ArrayView1<f64>,
        k: ArrayView1<f64>,
        dr: f64,
        dk: f64,
        cr: ArrayView3<f64>,
        wk: ArrayView3<f64>,
        p: ArrayView2<f64>,
        b: f64,
        uk_lr: ArrayView3<f64>,
        ur_lr: ArrayView3<f64>,
        chi: ArrayView3<f64>,
    ) -> (Array3<f64>, Array3<f64>) {
        let rtok = 2.0 * PI * dr;
        let ktor = dk / (4.0 * PI * PI);
        let identity: Array2<f64> = Array::eye(nsv);
        let mut ck = Array::zeros(cr.raw_dim());
        let mut hk = Array::zeros(cr.raw_dim());
        let mut tr = Array::zeros(cr.raw_dim());
        Zip::from(cr.lanes(Axis(0)))
            .and(ck.lanes_mut(Axis(0)))
            .par_for_each(|cr_lane, mut ck_lane| {
                ck_lane
                    .assign(
                        &fourier_bessel_transform_fftw(rtok, &r, &k, &cr_lane.to_owned()),
                    );
            });
        ck = ck - b * uk_lr.to_owned();
        Zip::from(hk.outer_iter_mut())
            .and(wk.outer_iter())
            .and(ck.outer_iter())
            .and(chi.outer_iter())
            .par_for_each(|mut hk_matrix, wk_matrix, ck_matrix, chi_matrix| {
                let w_bar = wk_matrix.to_owned() + p.dot(&chi_matrix);
                let iwcp = &identity - w_bar.dot(&ck_matrix.dot(&p));
                let inverted_iwcp = (iwcp).inv().expect("matrix inversion of:\n{iwcp}");
                let wcw = w_bar.dot(&ck_matrix.dot(&w_bar));
                hk_matrix.assign(&(inverted_iwcp.dot(&wcw) + chi_matrix));
            });
        let tk = &hk - ck;
        Zip::from(tk.lanes(Axis(0)))
            .and(tr.lanes_mut(Axis(0)))
            .par_for_each(|tk_lane, mut tr_lane| {
                tr_lane
                    .assign(
                        &fourier_bessel_transform_fftw(ktor, &k, &r, &tk_lane.to_owned()),
                    );
            });
        tr = tr - b * ur_lr.to_owned();
        (hk, tr)
    }
}
pub mod mdiis {
    use crate::data::DataRs;
    use crate::operator::Operator;
    use crate::solver::{Solver, SolverError, SolverSettings};
    use fftw::plan::*;
    use fftw::types::*;
    use log::warn;
    use ndarray_linalg::Solve;
    use numpy::ndarray::{Array, Array1, Array2, Array3};
    use std::collections::VecDeque;
    pub struct MDIIS {
        pub m: usize,
        pub mdiis_damping: f64,
        pub picard_damping: f64,
        pub max_iter: usize,
        pub tolerance: f64,
        fr: VecDeque<Array1<f64>>,
        res: VecDeque<Array1<f64>>,
        rms_res: VecDeque<f64>,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MDIIS {
        #[inline]
        fn clone(&self) -> MDIIS {
            MDIIS {
                m: ::core::clone::Clone::clone(&self.m),
                mdiis_damping: ::core::clone::Clone::clone(&self.mdiis_damping),
                picard_damping: ::core::clone::Clone::clone(&self.picard_damping),
                max_iter: ::core::clone::Clone::clone(&self.max_iter),
                tolerance: ::core::clone::Clone::clone(&self.tolerance),
                fr: ::core::clone::Clone::clone(&self.fr),
                res: ::core::clone::Clone::clone(&self.res),
                rms_res: ::core::clone::Clone::clone(&self.rms_res),
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for MDIIS {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            let names: &'static _ = &[
                "m",
                "mdiis_damping",
                "picard_damping",
                "max_iter",
                "tolerance",
                "fr",
                "res",
                "rms_res",
            ];
            let values: &[&dyn ::core::fmt::Debug] = &[
                &self.m,
                &self.mdiis_damping,
                &self.picard_damping,
                &self.max_iter,
                &self.tolerance,
                &self.fr,
                &self.res,
                &&self.rms_res,
            ];
            ::core::fmt::Formatter::debug_struct_fields_finish(f, "MDIIS", names, values)
        }
    }
    impl MDIIS {
        pub fn new(settings: &SolverSettings) -> Self {
            let mdiis_settings = settings
                .clone()
                .mdiis_settings
                .expect("MDIIS settings not found");
            MDIIS {
                m: mdiis_settings.depth,
                mdiis_damping: mdiis_settings.damping,
                picard_damping: settings.picard_damping,
                max_iter: settings.max_iter,
                tolerance: settings.tolerance,
                fr: VecDeque::new(),
                res: VecDeque::new(),
                rms_res: VecDeque::new(),
            }
        }
        fn step_picard(
            &mut self,
            curr: &Array3<f64>,
            prev: &Array3<f64>,
        ) -> Array3<f64> {
            let diff = curr.clone() - prev.clone();
            self.fr.push_back(Array::from_iter(curr.clone().into_iter()));
            self.res.push_back(Array::from_iter(diff.clone().into_iter()));
            prev + self.picard_damping * diff
        }
        fn step_mdiis(
            &mut self,
            curr: &Array3<f64>,
            prev: &Array3<f64>,
            gr: &Array3<f64>,
        ) -> Array1<f64> {
            let mut a = Array2::zeros((self.m + 1, self.m + 1));
            let mut b = Array1::zeros(self.m + 1);
            let gr = Array::from_iter(gr.clone().into_iter());
            b[[self.m]] = -1.0;
            for i in 0..self.m + 1 {
                a[[i, self.m]] = -1.0;
                a[[self.m, i]] = -1.0;
            }
            a[[self.m, self.m]] = 0.0;
            for i in 0..self.m {
                for j in 0..self.m {
                    a[[i, j]] = self.res[i].dot(&self.res[j]);
                }
            }
            let coefficients = a.solve_into(b).expect("could not perform linear solve");
            let mut c_a: Array1<f64> = Array::zeros(self.fr[0].raw_dim());
            let mut min_res: Array1<f64> = Array::zeros(self.fr[0].raw_dim());
            let denom = (1.0 + gr.mapv(|a| a.powf(2.0))).mapv(f64::sqrt);
            for i in 0..self.m {
                let modified_fr = &self.fr[i] * coefficients[i];
                let modified_res = &self.res[i] * coefficients[i] / &denom;
                c_a += &modified_fr;
                min_res += &modified_res;
            }
            let diff = curr.clone() - prev.clone();
            self.fr.push_back(Array::from_iter(curr.clone().into_iter()));
            self.res.push_back(Array::from_iter(diff.clone().into_iter()));
            self.fr.pop_front();
            self.res.pop_front();
            c_a + self.mdiis_damping * min_res
        }
    }
    impl Solver for MDIIS {
        fn solve(
            &mut self,
            problem: &mut DataRs,
            operator: &Operator,
        ) -> Result<(), SolverError> {
            {
                ::std::io::_print(
                    format_args!("Solving solvent-solvent RISM equation\n"),
                );
            };
            self.fr.clear();
            self.res.clear();
            self.rms_res.clear();
            let shape = problem.correlations.cr.dim();
            let (npts, ns1, ns2) = shape;
            let mut i = 0;
            let result = loop {
                let c_prev = problem.correlations.cr.clone();
                (operator.eq)(problem);
                let c_a = (operator.closure)(&problem);
                let mut c_next;
                if self.fr.len() < self.m {
                    c_next = self.step_picard(&c_a, &c_prev);
                    let rmse = compute_rmse(ns1, ns2, npts, &c_a, &c_prev);
                    self.rms_res.push_back(rmse)
                } else {
                    let gr = &c_a + &problem.correlations.tr;
                    c_next = self
                        .step_mdiis(&c_a, &c_prev, &gr)
                        .into_shape(shape)
                        .expect("could not reshape array into original shape");
                    let rmse = compute_rmse(ns1, ns2, npts, &c_a, &c_prev);
                    let rmse_min = self
                        .rms_res
                        .iter()
                        .fold(f64::INFINITY, |a, &b| a.min(b));
                    let min_index = self
                        .rms_res
                        .iter()
                        .position(|x| *x == rmse_min)
                        .expect("could not find index of minimum in rms_res");
                    if rmse > 10.0 * rmse_min {
                        {
                            let lvl = ::log::Level::Warn;
                            if lvl <= ::log::STATIC_MAX_LEVEL
                                && lvl <= ::log::max_level()
                            {
                                ::log::__private_api::log(
                                    format_args!("MDIIS restarting"),
                                    lvl,
                                    &("librism::mdiis", "librism::mdiis", "src/mdiis.rs"),
                                    155u32,
                                    ::log::__private_api::Option::None,
                                );
                            }
                        };
                        c_next = self
                            .fr[min_index]
                            .clone()
                            .into_shape(shape)
                            .expect("could not reshape array into original shape");
                        self.fr.clear();
                        self.res.clear();
                        self.rms_res.clear();
                    }
                    self.rms_res.push_back(rmse);
                    self.rms_res.pop_front();
                }
                problem.correlations.cr = c_next.clone();
                let rmse = conv_rmse(ns1, ns2, npts, problem.grid.dr, &c_next, &c_prev);
                {
                    ::std::io::_print(
                        format_args!(
                            "Iteration: {0}\tConvergence RMSE: {1:E}\n",
                            i,
                            rmse,
                        ),
                    );
                };
                if rmse <= self.tolerance {
                    break Ok(());
                }
                if rmse == std::f64::NAN || rmse == std::f64::INFINITY {
                    break Err(SolverError::ConvergenceError(i));
                }
                i += 1;
                if i == self.max_iter {
                    break Err(SolverError::MaxIterationError(i));
                }
            };
            result
        }
    }
    fn compute_rmse(
        ns1: usize,
        _ns2: usize,
        npts: usize,
        curr: &Array3<f64>,
        prev: &Array3<f64>,
    ) -> f64 {
        (1.0 / ns1 as f64 / npts as f64 * (curr - prev).sum().powf(2.0)).sqrt()
    }
    fn conv_rmse(
        ns1: usize,
        ns2: usize,
        npts: usize,
        dr: f64,
        curr: &Array3<f64>,
        prev: &Array3<f64>,
    ) -> f64 {
        let denom = 1.0 / ns1 as f64 / ns2 as f64 / npts as f64;
        (dr * (curr - prev).mapv(|x| x.powf(2.0)).sum() * denom).sqrt()
    }
}
pub mod operator {
    use crate::closure::ClosureKind;
    use crate::data::DataRs;
    use crate::integralequation::IntegralEquationKind;
    use ndarray::Array3;
    use pyo3::prelude::*;
    use std::fmt;
    pub enum CycleOrder {
        C2T2C,
        T2C2T,
    }
    pub struct OperatorConfig {
        pub integral_equation: IntegralEquationKind,
        pub closure: ClosureKind,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for OperatorConfig {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(OperatorConfig {
                    integral_equation: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "integral_equation",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "OperatorConfig",
                        "integral_equation",
                    )?,
                    closure: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "closure",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "OperatorConfig",
                        "closure",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for OperatorConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "OperatorConfig",
                "integral_equation",
                &self.integral_equation,
                "closure",
                &&self.closure,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for OperatorConfig {
        #[inline]
        fn clone(&self) -> OperatorConfig {
            OperatorConfig {
                integral_equation: ::core::clone::Clone::clone(&self.integral_equation),
                closure: ::core::clone::Clone::clone(&self.closure),
            }
        }
    }
    impl fmt::Display for OperatorConfig {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(
                format_args!(
                    "Integral Equation: {0}\nClosure: {1}",
                    self.integral_equation,
                    self.closure,
                ),
            )
        }
    }
    pub struct Operator {
        pub eq: fn(&mut DataRs),
        pub closure: fn(&DataRs) -> Array3<f64>,
    }
    impl Operator {
        pub fn new(config: &OperatorConfig) -> Self {
            Operator {
                eq: config.integral_equation.set(),
                closure: config.closure.set(),
            }
        }
    }
}
pub mod potential {
    use crate::data::Site;
    use errorfunctions::RealErrorFunctions;
    use itertools::Itertools;
    use ndarray::{s, Array1, Array3};
    use pyo3::{prelude::*, types::PyString};
    use std::f64::consts::PI;
    use std::fmt;
    pub enum PotentialKind {
        LennardJones,
        HardSpheres,
        Coulomb,
        NgRenormalisationReal,
        NgRenormalisationFourier,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for PotentialKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    PotentialKind::LennardJones => "LennardJones",
                    PotentialKind::HardSpheres => "HardSpheres",
                    PotentialKind::Coulomb => "Coulomb",
                    PotentialKind::NgRenormalisationReal => "NgRenormalisationReal",
                    PotentialKind::NgRenormalisationFourier => "NgRenormalisationFourier",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PotentialKind {
        #[inline]
        fn clone(&self) -> PotentialKind {
            match self {
                PotentialKind::LennardJones => PotentialKind::LennardJones,
                PotentialKind::HardSpheres => PotentialKind::HardSpheres,
                PotentialKind::Coulomb => PotentialKind::Coulomb,
                PotentialKind::NgRenormalisationReal => {
                    PotentialKind::NgRenormalisationReal
                }
                PotentialKind::NgRenormalisationFourier => {
                    PotentialKind::NgRenormalisationFourier
                }
            }
        }
    }
    impl<'source> FromPyObject<'source> for PotentialKind {
        fn extract(obj: &'source PyAny) -> PyResult<Self> {
            let str = obj
                .downcast::<PyString>()?
                .to_str()
                .map(ToOwned::to_owned)
                .expect("could not convert string");
            match str.as_str() {
                "LJ" => Ok(PotentialKind::LennardJones),
                "HS" => Ok(PotentialKind::HardSpheres),
                "COU" => Ok(PotentialKind::Coulomb),
                "NGR" => Ok(PotentialKind::NgRenormalisationReal),
                "NGK" => Ok(PotentialKind::NgRenormalisationFourier),
                _ => {
                    ::core::panicking::panic_fmt(format_args!("not a valid potential"));
                }
            }
        }
    }
    impl fmt::Display for PotentialKind {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                PotentialKind::LennardJones => f.write_fmt(format_args!("Lennard-Jones")),
                PotentialKind::HardSpheres => f.write_fmt(format_args!("Hard Spheres")),
                PotentialKind::Coulomb => f.write_fmt(format_args!("Coulomb")),
                PotentialKind::NgRenormalisationReal => {
                    f.write_fmt(format_args!("Ng Renormalisation (Real space)"))
                }
                PotentialKind::NgRenormalisationFourier => {
                    f.write_fmt(format_args!("Ng Renormalisation (Fourier space)"))
                }
            }
        }
    }
    impl PotentialKind {
        pub fn set(&self) -> fn(&[Site], &[Site], &Array1<f64>, &mut Array3<f64>) {
            match self {
                PotentialKind::LennardJones => lennard_jones,
                PotentialKind::HardSpheres => hard_spheres,
                PotentialKind::Coulomb => coulomb,
                PotentialKind::NgRenormalisationReal => ng_renormalisation_real,
                PotentialKind::NgRenormalisationFourier => ng_renormalisation_fourier,
            }
        }
    }
    pub struct PotentialConfig {
        pub nonbonded: PotentialKind,
        pub coulombic: PotentialKind,
        pub renormalisation_real: PotentialKind,
        pub renormalisation_fourier: PotentialKind,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for PotentialConfig {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(PotentialConfig {
                    nonbonded: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "nonbonded",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "PotentialConfig",
                        "nonbonded",
                    )?,
                    coulombic: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "coulombic",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "PotentialConfig",
                        "coulombic",
                    )?,
                    renormalisation_real: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "renormalisation_real",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "PotentialConfig",
                        "renormalisation_real",
                    )?,
                    renormalisation_fourier: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "renormalisation_fourier",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "PotentialConfig",
                        "renormalisation_fourier",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for PotentialConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field4_finish(
                f,
                "PotentialConfig",
                "nonbonded",
                &self.nonbonded,
                "coulombic",
                &self.coulombic,
                "renormalisation_real",
                &self.renormalisation_real,
                "renormalisation_fourier",
                &&self.renormalisation_fourier,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PotentialConfig {
        #[inline]
        fn clone(&self) -> PotentialConfig {
            PotentialConfig {
                nonbonded: ::core::clone::Clone::clone(&self.nonbonded),
                coulombic: ::core::clone::Clone::clone(&self.coulombic),
                renormalisation_real: ::core::clone::Clone::clone(
                    &self.renormalisation_real,
                ),
                renormalisation_fourier: ::core::clone::Clone::clone(
                    &self.renormalisation_fourier,
                ),
            }
        }
    }
    impl fmt::Display for PotentialConfig {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(format_args!("Potential: {0}", self.nonbonded))
        }
    }
    pub struct Potential {
        pub nonbonded: fn(&[Site], &[Site], &Array1<f64>, &mut Array3<f64>),
        pub coulombic: fn(&[Site], &[Site], &Array1<f64>, &mut Array3<f64>),
        pub renormalisation_real: fn(&[Site], &[Site], &Array1<f64>, &mut Array3<f64>),
        pub renormalisation_fourier: fn(
            &[Site],
            &[Site],
            &Array1<f64>,
            &mut Array3<f64>,
        ),
    }
    impl Potential {
        pub fn new(config: &PotentialConfig) -> Self {
            Potential {
                nonbonded: config.nonbonded.set(),
                coulombic: config.coulombic.set(),
                renormalisation_real: config.renormalisation_real.set(),
                renormalisation_fourier: config.renormalisation_fourier.set(),
            }
        }
    }
    fn geometric_mean(a: f64, b: f64) -> f64 {
        (a * b).sqrt()
    }
    fn arithmetic_mean(a: f64, b: f64) -> f64 {
        0.5 * (a + b)
    }
    fn lorentz_berthelot(eps1: f64, eps2: f64, sig1: f64, sig2: f64) -> (f64, f64) {
        (geometric_mean(eps1, eps2), arithmetic_mean(sig1, sig2))
    }
    pub fn lennard_jones(
        atoms_a: &[Site],
        atoms_b: &[Site],
        r: &Array1<f64>,
        result: &mut Array3<f64>,
    ) {
        let atom_pairs = atoms_a
            .iter()
            .enumerate()
            .cartesian_product(atoms_b.iter().enumerate());
        for ((i, site_a), (j, site_b)) in atom_pairs {
            let (eps, sig) = lorentz_berthelot(
                site_a.params[0],
                site_b.params[0],
                site_a.params[1],
                site_b.params[1],
            );
            result
                .slice_mut(
                    match .. {
                        r => {
                            match i {
                                r => {
                                    match j {
                                        r => {
                                            let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_in_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_in_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_out_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_out_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            #[allow(unsafe_code)]
                                            unsafe {
                                                ::ndarray::SliceInfo::new_unchecked(
                                                    [
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                    ],
                                                    in_dim,
                                                    out_dim,
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                )
                .assign({
                    let mut ir = sig / r;
                    let mut ir6 = ir.view_mut();
                    ir6.mapv_inplace(|a| a.powf(6.0));
                    let mut ir12 = ir6.to_owned().clone();
                    ir12.mapv_inplace(|a| a.powf(2.0));
                    &(4.0 * eps * (ir12.to_owned() - ir6.to_owned()))
                })
        }
    }
    pub fn hard_spheres(
        atoms_a: &[Site],
        atoms_b: &[Site],
        r: &Array1<f64>,
        result: &mut Array3<f64>,
    ) {
        let atom_pairs = atoms_a
            .iter()
            .enumerate()
            .cartesian_product(atoms_b.iter().enumerate());
        for ((i, site_a), (j, site_b)) in atom_pairs {
            let d = arithmetic_mean(site_a.params[0], site_b.params[0]);
            let mut out = r.clone();
            result
                .slice_mut(
                    match .. {
                        r => {
                            match i {
                                r => {
                                    match j {
                                        r => {
                                            let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_in_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_in_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_out_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_out_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            #[allow(unsafe_code)]
                                            unsafe {
                                                ::ndarray::SliceInfo::new_unchecked(
                                                    [
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                    ],
                                                    in_dim,
                                                    out_dim,
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                )
                .assign({
                    out.par_mapv_inplace(|x| {
                        let new_x;
                        if x <= d {
                            new_x = 0.0;
                        } else {
                            new_x = 1e30;
                        }
                        new_x
                    });
                    &out
                });
        }
    }
    pub fn coulomb(
        atoms_a: &[Site],
        atoms_b: &[Site],
        r: &Array1<f64>,
        result: &mut Array3<f64>,
    ) {
        let atom_pairs = atoms_a
            .iter()
            .enumerate()
            .cartesian_product(atoms_b.iter().enumerate());
        for ((i, site_a), (j, site_b)) in atom_pairs {
            let q = site_a.params.last().unwrap() * site_b.params.last().unwrap();
            result
                .slice_mut(
                    match .. {
                        r => {
                            match i {
                                r => {
                                    match j {
                                        r => {
                                            let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_in_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_in_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_out_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_out_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            #[allow(unsafe_code)]
                                            unsafe {
                                                ::ndarray::SliceInfo::new_unchecked(
                                                    [
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                    ],
                                                    in_dim,
                                                    out_dim,
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                )
                .assign(&(q / r.clone()));
        }
    }
    pub fn ng_renormalisation_real(
        atoms_a: &[Site],
        atoms_b: &[Site],
        r: &Array1<f64>,
        result: &mut Array3<f64>,
    ) {
        let atom_pairs = atoms_a
            .iter()
            .enumerate()
            .cartesian_product(atoms_b.iter().enumerate());
        for ((i, site_a), (j, site_b)) in atom_pairs {
            let q = site_a.params.last().unwrap() * site_b.params.last().unwrap();
            result
                .slice_mut(
                    match .. {
                        r => {
                            match i {
                                r => {
                                    match j {
                                        r => {
                                            let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_in_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_in_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_out_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_out_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            #[allow(unsafe_code)]
                                            unsafe {
                                                ::ndarray::SliceInfo::new_unchecked(
                                                    [
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                    ],
                                                    in_dim,
                                                    out_dim,
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                )
                .assign({
                    let mut erf_r = r.clone();
                    erf_r.par_mapv_inplace(|x| x.erf());
                    &(q * erf_r / r)
                });
        }
    }
    pub fn ng_renormalisation_fourier(
        atoms_a: &[Site],
        atoms_b: &[Site],
        k: &Array1<f64>,
        result: &mut Array3<f64>,
    ) {
        let atom_pairs = atoms_a
            .iter()
            .enumerate()
            .cartesian_product(atoms_b.iter().enumerate());
        for ((i, site_a), (j, site_b)) in atom_pairs {
            let q = site_a.params.last().unwrap() * site_b.params.last().unwrap();
            result
                .slice_mut(
                    match .. {
                        r => {
                            match i {
                                r => {
                                    match j {
                                        r => {
                                            let in_dim = ::ndarray::SliceNextDim::next_in_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_in_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_in_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            let out_dim = ::ndarray::SliceNextDim::next_out_dim(
                                                &r,
                                                ::ndarray::SliceNextDim::next_out_dim(
                                                    &r,
                                                    ::ndarray::SliceNextDim::next_out_dim(
                                                        &r,
                                                        ::core::marker::PhantomData::<::ndarray::Ix0>,
                                                    ),
                                                ),
                                            );
                                            #[allow(unsafe_code)]
                                            unsafe {
                                                ::ndarray::SliceInfo::new_unchecked(
                                                    [
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                        <::ndarray::SliceInfoElem as ::core::convert::From<
                                                            _,
                                                        >>::from(r),
                                                    ],
                                                    in_dim,
                                                    out_dim,
                                                )
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                )
                .assign({
                    let mut exp_k = k.clone();
                    let mut k2 = k.clone();
                    k2.par_mapv_inplace(|x| x.powf(2.0));
                    exp_k.par_mapv_inplace(|x| (-1.0 * x.powf(2.0) / 4.0).exp());
                    &(q * 4.0 * PI * exp_k / k2)
                });
        }
    }
}
pub mod quaternion {
    use ndarray::{arr1, Array, Array1, Array2};
    impl std::ops::Add<Quaternion> for Quaternion {
        type Output = Quaternion;
        fn add(self, other: Quaternion) -> Self::Output {
            Quaternion([
                self.0[0].add(other.0[0]),
                self.0[1].add(other.0[1]),
                self.0[2].add(other.0[2]),
                self.0[3].add(other.0[3]),
            ])
        }
    }
    impl std::ops::Add<&Quaternion> for &Quaternion {
        type Output = Quaternion;
        fn add(self, other: &Quaternion) -> Self::Output {
            Quaternion([
                self.0[0].add(other.0[0]),
                self.0[1].add(other.0[1]),
                self.0[2].add(other.0[2]),
                self.0[3].add(other.0[3]),
            ])
        }
    }
    impl std::ops::Add<Quaternion> for &Quaternion {
        type Output = Quaternion;
        fn add(self, other: Quaternion) -> Self::Output {
            Quaternion([
                self.0[0].add(other.0[0]),
                self.0[1].add(other.0[1]),
                self.0[2].add(other.0[2]),
                self.0[3].add(other.0[3]),
            ])
        }
    }
    impl std::ops::Add<&Quaternion> for Quaternion {
        type Output = Quaternion;
        fn add(self, other: &Quaternion) -> Self::Output {
            Quaternion([
                self.0[0].add(other.0[0]),
                self.0[1].add(other.0[1]),
                self.0[2].add(other.0[2]),
                self.0[3].add(other.0[3]),
            ])
        }
    }
    impl std::ops::Sub<Quaternion> for Quaternion {
        type Output = Quaternion;
        fn sub(self, other: Quaternion) -> Self::Output {
            Quaternion([
                self.0[0].sub(other.0[0]),
                self.0[1].sub(other.0[1]),
                self.0[2].sub(other.0[2]),
                self.0[3].sub(other.0[3]),
            ])
        }
    }
    impl std::ops::Sub<&Quaternion> for &Quaternion {
        type Output = Quaternion;
        fn sub(self, other: &Quaternion) -> Self::Output {
            Quaternion([
                self.0[0].sub(other.0[0]),
                self.0[1].sub(other.0[1]),
                self.0[2].sub(other.0[2]),
                self.0[3].sub(other.0[3]),
            ])
        }
    }
    impl std::ops::Sub<Quaternion> for &Quaternion {
        type Output = Quaternion;
        fn sub(self, other: Quaternion) -> Self::Output {
            Quaternion([
                self.0[0].sub(other.0[0]),
                self.0[1].sub(other.0[1]),
                self.0[2].sub(other.0[2]),
                self.0[3].sub(other.0[3]),
            ])
        }
    }
    impl std::ops::Sub<&Quaternion> for Quaternion {
        type Output = Quaternion;
        fn sub(self, other: &Quaternion) -> Self::Output {
            Quaternion([
                self.0[0].sub(other.0[0]),
                self.0[1].sub(other.0[1]),
                self.0[2].sub(other.0[2]),
                self.0[3].sub(other.0[3]),
            ])
        }
    }
    impl std::ops::AddAssign<Quaternion> for Quaternion {
        fn add_assign(&mut self, other: Quaternion) {
            self.0[0].add_assign(other.0[0]);
            self.0[1].add_assign(other.0[1]);
            self.0[2].add_assign(other.0[2]);
            self.0[3].add_assign(other.0[3]);
        }
    }
    impl std::ops::AddAssign<&Quaternion> for Quaternion {
        fn add_assign(&mut self, other: &Quaternion) {
            self.0[0].add_assign(other.0[0]);
            self.0[1].add_assign(other.0[1]);
            self.0[2].add_assign(other.0[2]);
            self.0[3].add_assign(other.0[3]);
        }
    }
    impl std::ops::SubAssign<Quaternion> for Quaternion {
        fn sub_assign(&mut self, other: Quaternion) {
            self.0[0].sub_assign(other.0[0]);
            self.0[1].sub_assign(other.0[1]);
            self.0[2].sub_assign(other.0[2]);
            self.0[3].sub_assign(other.0[3]);
        }
    }
    impl std::ops::SubAssign<&Quaternion> for Quaternion {
        fn sub_assign(&mut self, other: &Quaternion) {
            self.0[0].sub_assign(other.0[0]);
            self.0[1].sub_assign(other.0[1]);
            self.0[2].sub_assign(other.0[2]);
            self.0[3].sub_assign(other.0[3]);
        }
    }
    pub struct Quaternion([f64; 4]);
    #[automatically_derived]
    impl ::core::clone::Clone for Quaternion {
        #[inline]
        fn clone(&self) -> Quaternion {
            Quaternion(::core::clone::Clone::clone(&self.0))
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Quaternion {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(f, "Quaternion", &&self.0)
        }
    }
    impl Quaternion {
        pub fn new(input_arr: [f64; 4]) -> Self {
            Quaternion(input_arr)
        }
        pub fn conj(&self) -> Self {
            Quaternion::new([self.0[0], -self.0[1], -self.0[2], -self.0[3]])
        }
        pub fn rotate(&self, vec: &Array1<f64>) -> Array1<f64> {
            let _quat_raw_vec = [0.0, vec[0], vec[1], vec[2]];
            let q_vec = Quaternion::new(_quat_raw_vec);
            let q_temp = self * q_vec;
            let q_conj = self.conj();
            let q_vec = q_temp * q_conj;
            arr1(&[q_vec.0[1], q_vec.0[2], q_vec.0[3]])
        }
        pub fn from_axis_angle(angle: f64, axis: &Array1<f64>) -> Self {
            let magnitude = axis.mapv(|x| x.powf(2.0)).sum().sqrt();
            let scalar_w = (angle / 2.0).cos();
            match magnitude == 0.0 {
                true => Quaternion([scalar_w, 0.0, 0.0, 0.0]),
                _ => {
                    let quat1to3 = axis / magnitude * (angle / 2.0).sin();
                    Quaternion([scalar_w, quat1to3[0], quat1to3[1], quat1to3[2]])
                }
            }
        }
        pub fn to_rotation_matrix(&self) -> Array2<f64> {
            let mut out_arr = Array::zeros((3, 3));
            let (q0, q1, q2, q3) = (self.0[0], self.0[1], self.0[2], self.0[3]);
            out_arr[[0, 0]] = 2.0 * (q0 * q0 + q1 * q1) - 1.0;
            out_arr[[0, 1]] = 2.0 * (q1 * q2 - q0 * q3);
            out_arr[[0, 2]] = 2.0 * (q1 * q3 + q0 * q2);
            out_arr[[1, 0]] = 2.0 * (q1 * q2 + q0 * q3);
            out_arr[[1, 1]] = 2.0 * (q0 * q0 + q2 * q2) - 1.0;
            out_arr[[1, 2]] = 2.0 * (q2 * q3 - q0 * q1);
            out_arr[[2, 0]] = 2.0 * (q1 * q3 - q0 * q2);
            out_arr[[2, 1]] = 2.0 * (q2 * q3 + q0 * q1);
            out_arr[[2, 2]] = 2.0 * (q0 * q0 + q3 * q3) - 1.0;
            out_arr
        }
    }
    pub fn cross_product(a: &Array1<f64>, b: &Array1<f64>) -> Array1<f64> {
        let mut out_arr = Array::zeros(3);
        out_arr[[0]] = a[[1]] * b[[2]] - a[[2]] * b[[1]];
        out_arr[[1]] = a[[2]] * b[[0]] - a[[0]] * b[[2]];
        out_arr[[2]] = a[[0]] * b[[1]] - a[[1]] * b[[0]];
        out_arr
    }
    impl std::ops::Mul<Quaternion> for Quaternion {
        type Output = Quaternion;
        fn mul(self, other: Quaternion) -> Self::Output {
            let mut out_arr: [f64; 4] = [0.0, 0.0, 0.0, 0.0];
            let a = self.0;
            let b = other.0;
            out_arr[0] = a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3];
            out_arr[1] = a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2];
            out_arr[2] = a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1];
            out_arr[3] = a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0];
            Quaternion(out_arr)
        }
    }
    impl std::ops::Mul<&Quaternion> for Quaternion {
        type Output = Quaternion;
        fn mul(self, other: &Quaternion) -> Self::Output {
            let mut out_arr: [f64; 4] = [0.0, 0.0, 0.0, 0.0];
            let a = self.0;
            let b = other.0;
            out_arr[0] = a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3];
            out_arr[1] = a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2];
            out_arr[2] = a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1];
            out_arr[3] = a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0];
            Quaternion(out_arr)
        }
    }
    impl std::ops::Mul<&Quaternion> for &Quaternion {
        type Output = Quaternion;
        fn mul(self, other: &Quaternion) -> Self::Output {
            let mut out_arr: [f64; 4] = [0.0, 0.0, 0.0, 0.0];
            let a = self.0;
            let b = other.0;
            out_arr[0] = a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3];
            out_arr[1] = a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2];
            out_arr[2] = a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1];
            out_arr[3] = a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0];
            Quaternion(out_arr)
        }
    }
    impl std::ops::Mul<Quaternion> for &Quaternion {
        type Output = Quaternion;
        fn mul(self, other: Quaternion) -> Self::Output {
            let mut out_arr: [f64; 4] = [0.0, 0.0, 0.0, 0.0];
            let a = self.0;
            let b = other.0;
            out_arr[0] = a[0] * b[0] - a[1] * b[1] - a[2] * b[2] - a[3] * b[3];
            out_arr[1] = a[0] * b[1] + a[1] * b[0] + a[2] * b[3] - a[3] * b[2];
            out_arr[2] = a[0] * b[2] - a[1] * b[3] + a[2] * b[0] + a[3] * b[1];
            out_arr[3] = a[0] * b[3] + a[1] * b[2] - a[2] * b[1] + a[3] * b[0];
            Quaternion(out_arr)
        }
    }
}
pub mod solver {
    use crate::data::DataRs;
    use crate::mdiis::MDIIS;
    use crate::operator::Operator;
    use pyo3::{prelude::*, types::PyString};
    use std::fmt::{self, Debug, Display};
    pub enum SolverError {
        ConvergenceError(usize),
        MaxIterationError(usize),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SolverError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                SolverError::ConvergenceError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "ConvergenceError",
                        &__self_0,
                    )
                }
                SolverError::MaxIterationError(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "MaxIterationError",
                        &__self_0,
                    )
                }
            }
        }
    }
    impl Display for SolverError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                SolverError::ConvergenceError(i) => {
                    f.write_fmt(format_args!("Solver diverged at iteration {0}", i))
                }
                SolverError::MaxIterationError(i) => {
                    f.write_fmt(format_args!("Max iteration reach at {0}", i))
                }
            }
        }
    }
    impl std::error::Error for SolverError {}
    pub trait Solver: Debug {
        fn solve(
            &mut self,
            data: &mut DataRs,
            operator: &Operator,
        ) -> Result<(), SolverError>;
    }
    pub struct MDIISSettings {
        pub depth: usize,
        pub damping: f64,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for MDIISSettings {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(MDIISSettings {
                    depth: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "depth",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "MDIISSettings",
                        "depth",
                    )?,
                    damping: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "damping",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "MDIISSettings",
                        "damping",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for MDIISSettings {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "MDIISSettings",
                "depth",
                &self.depth,
                "damping",
                &&self.damping,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MDIISSettings {
        #[inline]
        fn clone(&self) -> MDIISSettings {
            MDIISSettings {
                depth: ::core::clone::Clone::clone(&self.depth),
                damping: ::core::clone::Clone::clone(&self.damping),
            }
        }
    }
    pub struct GillanSettings {
        pub nbasis: usize,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for GillanSettings {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(GillanSettings {
                    nbasis: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "nbasis",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "GillanSettings",
                        "nbasis",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for GillanSettings {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "GillanSettings",
                "nbasis",
                &&self.nbasis,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for GillanSettings {
        #[inline]
        fn clone(&self) -> GillanSettings {
            GillanSettings {
                nbasis: ::core::clone::Clone::clone(&self.nbasis),
            }
        }
    }
    pub struct SolverSettings {
        pub picard_damping: f64,
        pub max_iter: usize,
        pub tolerance: f64,
        pub gillan_settings: Option<GillanSettings>,
        pub mdiis_settings: Option<MDIISSettings>,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for SolverSettings {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(SolverSettings {
                    picard_damping: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "picard_damping",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "SolverSettings",
                        "picard_damping",
                    )?,
                    max_iter: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "max_iter",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "SolverSettings",
                        "max_iter",
                    )?,
                    tolerance: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "tolerance",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "SolverSettings",
                        "tolerance",
                    )?,
                    gillan_settings: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "gillan_settings",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "SolverSettings",
                        "gillan_settings",
                    )?,
                    mdiis_settings: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "mdiis_settings",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "SolverSettings",
                        "mdiis_settings",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for SolverSettings {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "SolverSettings",
                "picard_damping",
                &self.picard_damping,
                "max_iter",
                &self.max_iter,
                "tolerance",
                &self.tolerance,
                "gillan_settings",
                &self.gillan_settings,
                "mdiis_settings",
                &&self.mdiis_settings,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SolverSettings {
        #[inline]
        fn clone(&self) -> SolverSettings {
            SolverSettings {
                picard_damping: ::core::clone::Clone::clone(&self.picard_damping),
                max_iter: ::core::clone::Clone::clone(&self.max_iter),
                tolerance: ::core::clone::Clone::clone(&self.tolerance),
                gillan_settings: ::core::clone::Clone::clone(&self.gillan_settings),
                mdiis_settings: ::core::clone::Clone::clone(&self.mdiis_settings),
            }
        }
    }
    pub struct SolverConfig {
        pub solver: SolverKind,
        pub settings: SolverSettings,
    }
    const _: () = {
        use ::pyo3 as _pyo3;
        #[automatically_derived]
        impl<'source> _pyo3::FromPyObject<'source> for SolverConfig {
            fn extract(obj: &'source _pyo3::PyAny) -> _pyo3::PyResult<Self> {
                ::std::result::Result::Ok(SolverConfig {
                    solver: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "solver",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "SolverConfig",
                        "solver",
                    )?,
                    settings: _pyo3::impl_::frompyobject::extract_struct_field(
                        obj
                            .getattr({
                                static INTERNED: ::pyo3::sync::Interned = ::pyo3::sync::Interned::new(
                                    "settings",
                                );
                                INTERNED.get(obj.py())
                            })?,
                        "SolverConfig",
                        "settings",
                    )?,
                })
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for SolverConfig {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field2_finish(
                f,
                "SolverConfig",
                "solver",
                &self.solver,
                "settings",
                &&self.settings,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SolverConfig {
        #[inline]
        fn clone(&self) -> SolverConfig {
            SolverConfig {
                solver: ::core::clone::Clone::clone(&self.solver),
                settings: ::core::clone::Clone::clone(&self.settings),
            }
        }
    }
    impl fmt::Display for SolverConfig {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            f.write_fmt(format_args!("Solver: {0}", self.solver))
        }
    }
    pub enum SolverKind {
        Picard,
        Ng,
        MDIIS,
        Gillan,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for SolverKind {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(
                f,
                match self {
                    SolverKind::Picard => "Picard",
                    SolverKind::Ng => "Ng",
                    SolverKind::MDIIS => "MDIIS",
                    SolverKind::Gillan => "Gillan",
                },
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for SolverKind {
        #[inline]
        fn clone(&self) -> SolverKind {
            match self {
                SolverKind::Picard => SolverKind::Picard,
                SolverKind::Ng => SolverKind::Ng,
                SolverKind::MDIIS => SolverKind::MDIIS,
                SolverKind::Gillan => SolverKind::Gillan,
            }
        }
    }
    impl fmt::Display for SolverKind {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            match self {
                SolverKind::Picard => f.write_fmt(format_args!("Picard")),
                SolverKind::Ng => f.write_fmt(format_args!("Ng")),
                SolverKind::MDIIS => f.write_fmt(format_args!("MDIIS")),
                SolverKind::Gillan => f.write_fmt(format_args!("Gillan")),
            }
        }
    }
    impl<'source> FromPyObject<'source> for SolverKind {
        fn extract(obj: &'source PyAny) -> PyResult<Self> {
            let str = obj
                .downcast::<PyString>()?
                .to_str()
                .map(ToOwned::to_owned)
                .expect("could not convert string");
            match str.as_str() {
                "Picard" => Ok(SolverKind::Picard),
                "Ng" => Ok(SolverKind::Ng),
                "MDIIS" => Ok(SolverKind::MDIIS),
                "Gillan" => Ok(SolverKind::Gillan),
                _ => {
                    ::core::panicking::panic_fmt(format_args!("not a valid solver"));
                }
            }
        }
    }
    impl SolverKind {
        pub fn set(&self, settings: &SolverSettings) -> impl Solver {
            match self {
                SolverKind::MDIIS => MDIIS::new(settings),
                _ => {
                    ::core::panicking::panic_fmt(format_args!("solver unimplemented"));
                }
            }
        }
    }
}
pub mod transforms {
    use fftw::plan::*;
    use fftw::types::*;
    use ndarray::{Array1, ArrayView1};
    use rustdct::TransformType4;
    use std::sync::Arc;
    type FFTPlan = Arc<dyn TransformType4<f64>>;
    pub fn fourier_bessel_transform(
        prefac: f64,
        grid1: &ArrayView1<f64>,
        grid2: &ArrayView1<f64>,
        func: &Array1<f64>,
        plan: &FFTPlan,
    ) -> Array1<f64> {
        let mut buffer = (func * grid1).to_vec();
        plan.process_dst4(&mut buffer);
        let fac = grid2.mapv(|v| prefac / v);
        fac * Array1::from_vec(buffer)
    }
    pub fn fourier_bessel_transform_fftw(
        prefac: f64,
        grid1: &ArrayView1<f64>,
        grid2: &ArrayView1<f64>,
        func: &Array1<f64>,
    ) -> Array1<f64> {
        let arr = func * grid1;
        let mut r2r: R2RPlan64 = R2RPlan::aligned(
                &[grid1.len()],
                R2RKind::FFTW_RODFT11,
                Flag::ESTIMATE,
            )
            .expect("could not execute FFTW plan");
        let mut input = arr.as_standard_layout();
        let mut output = Array1::zeros(input.raw_dim());
        r2r.r2r(input.as_slice_mut().unwrap(), output.as_slice_mut().unwrap())
            .expect("could not perform DST-IV operation");
        prefac * output / grid2
    }
}
/// A Python module implemented in Rust. The name of this function must match
/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to
/// import the module.
fn librism(_py: Python<'_>, m: &PyModule) -> PyResult<()> {
    m.add_class::<RISMDriver>()?;
    Ok(())
}
#[doc(hidden)]
mod librism {
    pub(crate) struct MakeDef;
    pub static DEF: ::pyo3::impl_::pymodule::ModuleDef = MakeDef::make_def();
    pub const NAME: &'static str = "librism\u{0}";
    /// This autogenerated function is called by the python interpreter when importing
    /// the module.
    #[export_name = "PyInit_librism"]
    pub unsafe extern "C" fn init() -> *mut ::pyo3::ffi::PyObject {
        ::pyo3::impl_::trampoline::module_init(|py| DEF.make_module(py))
    }
}
const _: () = {
    use ::pyo3::impl_::pymodule as impl_;
    impl librism::MakeDef {
        const fn make_def() -> impl_::ModuleDef {
            const INITIALIZER: impl_::ModuleInitializer = impl_::ModuleInitializer(
                librism,
            );
            unsafe {
                impl_::ModuleDef::new(
                    librism::NAME,
                    "A Python module implemented in Rust. The name of this function must match\nthe `lib.name` setting in the `Cargo.toml`, else Python will not be able to\nimport the module.\0",
                    INITIALIZER,
                )
            }
        }
    }
};
